<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>96_xuan18.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>96_xuan18.java</CENTER></H3><HR>
<PRE>
class ExamRoom {
    
    class Interval implements Comparable&lt;Interval&gt; {
        
        // represents the interval [begin..end]
        int begin;
<A NAME="0"></A>        int end;
        int totalSeats;
        
        public Interval(int b, int e, int total) { begin = b; <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match18-1.html#0',3,'match18-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>end = e; totalSeats = total; }
        
        public int getSeatLocation() {
            if (begin == 0) {
                return 0;
            }</B></FONT> else if(end == total - 1) {
                return end;
            } else {
                return begin + (end - begin) / 2;
            }
        }
        
        public int getDistanceForNextSeat() {
            if (begin == 0 &amp;&amp; end == total - 1) {
                return total + 1;
            } else {
                int seat = getSeatLocation();
                if (begin == 0) {
                    return end - seat + 1;
                } else if (end == total - 1) {
                    return seat - begin + 1;
                } else {
                    return Math.min(seat - begin, end - seat) + 1;
                }
            }
        }
        
        public List&lt;Interval&gt; split(int seat) {
            if(seat&lt;begin || seat&gt;end) {
                throw new RuntimeException(&quot;Interval &quot; + this + &quot; cannot be split at &quot; + seat);
            }
            LinkedList&lt;Interval&gt; ret = new LinkedList&lt;Interval&gt;();
            if(begin!=seat) {
                ret.add(new Interval(begin, seat-1, total));
            }
            if(end!=seat) {
                ret.add(new Interval(seat+1, end, total));
            }
            return ret;
        }
        
        public int compareTo(Interval i) {
            int dist1 = this.getDistanceForNextSeat(), dist2 = i.getDistanceForNextSeat();
            if(dist1 &gt; dist2) {
                return -1;
            } else if (dist1 &lt; dist2) {
                return 1;
            } else if(begin &lt; i.begin) {
                return -1;
            } else if(begin &gt; i.begin) {
                return 1;
            } else {
                return 0;
            }
        }
        
        public boolean equals(Object o) {
            if (!(o instanceof Interval)) {
                return false;
            } else {
                return (compareTo((Interval)o) == 0);
            }
        }
        
        public String toString() {
            return &quot;[&quot; + begin + &quot;,&quot; + end + &quot;]&quot;;
        }
    }
    
    int total;
    TreeSet&lt;Interval&gt; cur;
    HashMap&lt;Integer, Interval&gt; leftEndpointMap, rightEndpointMap;

    public ExamRoom(int N) {
        total = N;
        cur = new TreeSet&lt;Interval&gt;();
        leftEndpointMap = new HashMap&lt;Integer, Interval&gt;();
        rightEndpointMap = new HashMap&lt;Integer, Interval&gt;();
        addInterval(new Interval(0, N-1, N));   
    }
    
    private void addInterval(Interval interval) {
        cur.add(interval);
        if(leftEndpointMap.containsKey(interval.begin)) {
            throw new RuntimeException(&quot;Adding interval &quot; + interval + 
                                       &quot; but leftEndpointMap has conflict &quot; + leftEndpointMap.get(interval.begin));
        }
        if(rightEndpointMap.containsKey(interval.end)) {
            throw new RuntimeException(&quot;Adding interval &quot; + interval + 
                                       &quot; but leftEndpointMap has conflict &quot; + rightEndpointMap.get(interval.end));
        }
        leftEndpointMap.put(interval.begin, interval);
        rightEndpointMap.put(interval.end, interval);
    }
    
    private void removeInterval(Interval interval) {
        if (!cur.contains(interval)) {
            throw new RuntimeException(&quot;Interval &quot; + interval + &quot; not found. Cannot remove.&quot;);
        }
        if(!leftEndpointMap.containsKey(interval.begin)) {
            throw new RuntimeException(&quot;Interval &quot; + interval + &quot; not found for leftEndpointMap. Cannot remove.&quot;);
        }
        if(!rightEndpointMap.containsKey(interval.end)) {
            throw new RuntimeException(&quot;Interval &quot; + interval + &quot; not found for rightEndpointMap. Cannot remove.&quot;);
        }
        cur.remove(interval);
        Interval tmp;
        tmp = leftEndpointMap.get(interval.begin);
        if(tmp.begin != interval.begin || tmp.end != interval.end) {
            throw new RuntimeException(&quot;Interval &quot; + interval + &quot; not found for leftEndpointMap. Found &quot; + tmp + &quot; instead.&quot;);
        }
        tmp = rightEndpointMap.get(interval.end);
        if(tmp.begin != interval.begin || tmp.end != interval.end) {
            throw new RuntimeException(&quot;Interval &quot; + interval + &quot; not found for rightEndpointMap. Found &quot; + tmp + &quot; instead.&quot;);
        }
        leftEndpointMap.remove(interval.begin);
        rightEndpointMap.remove(interval.end);
    }
    
    public int seat() {
        Interval interval = cur.first();
        int ret = interval.getSeatLocation();
        removeInterval(interval);
        List&lt;Interval&gt; toAdd = interval.split(ret);
        for(Interval next : toAdd) {
            addInterval(next);
        }
        return ret;
    }
    
    private Interval merge(Interval left, int seat, Interval right) {
        int l = seat, r = seat;
        if(left != null) l = left.begin;
        if(right != null) r = right.end;
        return new Interval(l, r, total);
    }
    
    public void leave(int p) {
        Interval left = rightEndpointMap.get(p-1);
        Interval right = leftEndpointMap.get(p+1);
        Interval toAdd = merge(left, p, right);
        if(left != null) {
            removeInterval(left);
        }
        if(right != null) {
            removeInterval(right);
        }
        addInterval(toAdd);
    }
}

/**
 * Your ExamRoom object will be instantiated and called as such:
 * ExamRoom obj = new ExamRoom(N);
 * int param_1 = obj.seat();
 * obj.leave(p);
 */
</PRE>

</BODY>
</HTML>
