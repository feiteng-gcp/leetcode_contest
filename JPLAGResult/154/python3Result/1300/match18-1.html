<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>62_shshwdr.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>62_shshwdr.py</CENTER></H3><HR>
<PRE>
import bisect
from collections import defaultdict
import datetime
import string
import time
from datetime import date
import calendar
import heapq
class Solution:
        def init(self,vertices): 
<A NAME="0"></A>            self.V= vertices #No. of vertices 
            self.graph = defaultdict(list) # default dictionary to store graph 
            self.Time = 0
            self<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match18-0.html#0',2,'match18-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>.res = []
        def addEdge(self,u,v): 
            self.graph[u].append(v) 
            self.graph[v].append(u) 

        '''A recursive function that finds and prints bridges 
        using DFS traversal 
        u --&gt; The vertex to be visited next 
        visited[] --&gt; keeps tract of visited vertices 
        disc[] --&gt; Stores discovery times of visited vertices 
        parent[] --&gt; Stores parent vertices in DFS tree'''
        def bridgeUtil(self,u, visited, parent, low, disc): 

            # Mark the current node as visited and print it 
            visited[u]= True

            # Initialize discovery time and low value 
            disc[u] = self.Time 
            low[u] = self.Time 
            self.Time += 1

            #Recur for all the vertices adjacent to this vertex 
            for v in self.graph[u]: 
                # If v is not visited yet, then make it a child of u 
                # in DFS tree and recur for it 
                if visited[v] == False : 
                    parent[v] = u 
                    self.bridgeUtil(v, visited, parent, low, disc) 

                    # Check if the subtree rooted with v has a connection to 
                    # one of the ancestors of u 
                    low[u] = min(low[u], low[v]) 


                    ''' If the lowest vertex reachable from subtree 
                    under v is below u in DFS tree, then u-v is 
                    a bridge'''
                    if low[v] &gt; disc[u]: 
                        self.res.append([u,v])


                elif v != parent[u]: # Update low value of u for parent function calls. 
                    low[u] = min(low[u], disc[v]) 


        # DFS based function to find all bridges. It uses recursive 
        # function bridgeUtil() 
        def bridge(self): 

            # Mark all the vertices as not visited and Initialize parent and visited,  
            # and ap(articulation point) arrays 
            visited = [False] * (self.V) 
            disc = [float(&quot;Inf&quot;)] * (self.V) 
            low = [float(&quot;Inf&quot;)] * (self.V) 
            parent = [-1] * (self.V) 

            # Call the recursive helper function to find bridges 
            # in DFS tree rooted with vertex 'i' 
            for i in range(self.V): 
                if visited[i] == False: 
                    self.bridgeUtil(i,</B></FONT> visited, parent, low, disc) 
        def criticalConnections(self, n: int, cs):
            self.init(n)
            for c,s in cs:
                self.addEdge(c,s)
            self.bridge()
            return self.res
</PRE>

</BODY>
</HTML>
