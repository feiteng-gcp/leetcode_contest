<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>166_scau_grated.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>166_scau_grated.cpp</CENTER></H3><HR>
<PRE>
<A NAME="0"></A>const int maxn=100000+10;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match12-0.html#0',2,'match12-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int n,m;
int dfs_clock;//时钟，每访问一个节点增1
vector&lt;int&gt; G[maxn];//G[i]表示i节点邻接的所有节点
int pre[maxn];//pre[i]表示i节点被第一次访问到的时间戳,若pre[i]==0表示i还未被访问
int low[maxn];//low[i]表示i节点及其后代能通过反向边连回的最早的祖先的pre值
bool iscut[maxn];//标记i节点是不是一个割点
vector&lt;vector&lt;int&gt;&gt; global_ret;

//求出以u为根节点(u在DFS树中的父节点是fa)的树的所有割顶和桥
//初始调用为dfs(root,-1);
int dfs(int u,int fa)
{
    int lowu=pre[u]=++dfs_clock;
    int child=0;    //子节点数目
    for(int i=0; i&lt;G[u].size(); i++)
    {
        int v=G[u][i];
        if(!pre[v])
        {
            child++;//未访问过的节点才能算是u的孩子
            int lowv=dfs(v,u);
            lowu=min(lowu,lowv);
            if(lowv&gt;=pre[u])
            {
                iscut[u]=true;      //u点是割顶
<A NAME="1"></A>                if(lowv&gt;pre[u]) {   //(u,v)边是桥</B></FONT>
                    //printf(&quot;边(%d, %d)是桥\n&quot;,u,v);
                    global_ret.push_back({u, v});
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match12-0.html#1',2,'match12-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>                }
            }
        }
        else if(pre[v]&lt;pre[u] &amp;&amp; v!=fa)//v!=fa确保了(u,v)是从u到v的反向边
        {
            lowu=min(lowu,pre[v]);
        }
    }
    if(fa&lt;0 &amp;&amp; child==1 )
        iscut[u]=false;//u若是根且孩子数&lt;=1,那u就不是割顶
    return low[u]=lowu;
}</B></FONT>

class Solution {
  public:
  vector&lt;vector&lt;int&gt;&gt; criticalConnections(int vertexn, vector&lt;vector&lt;int&gt;&gt;&amp; connections) {
    dfs_clock=0;//初始化时钟
    memset(pre,0,sizeof(pre));
    memset(iscut,0,sizeof(iscut));
    n = vertexn;
    m = connections.size();
    global_ret.clear();
    for (int i = 0; i &lt; n; ++i) G[i].clear();
    for (auto&amp; x : connections) {
      int u = x[0];
      int v = x[1];

      G[u].push_back(v);
      G[v].push_back(u);
    }

    dfs(0,-1);//初始调用
    return global_ret;
  }
};
</PRE>
</BODY>
</HTML>
