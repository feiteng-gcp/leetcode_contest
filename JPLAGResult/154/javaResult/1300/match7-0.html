<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>437_sangreal.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>437_sangreal.java</CENTER></H3><HR>
<PRE>
class Solution {
<A NAME="0"></A>    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

     class Graph {
         <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match7-1.html#0',3,'match7-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>private int V;   // No. of vertices

         // Array  of lists for Adjacency List Representation
         private LinkedList&lt;Integer&gt; adj[];
         int time = 0;
         static final int NIL = -1;

         // Constructor
         Graph(int v) {
             V = v;
             adj = new LinkedList[v];
             for (int i = 0; i &lt; v; ++i)
                 adj[i] = new LinkedList();
         }

         // Function to add an edge into the graph
         void addEdge(int v, int w) {
             adj[v].add(w);  // Add w to v's list.
             adj[w].add(v);    //Add v to w's list
         }

         // A recursive function that finds and prints bridges
         // using DFS traversal
         // u --&gt; The vertex to be visited next
         // visited[] --&gt; keeps tract of visited vertices
         // disc[] --&gt; Stores discovery times of visited vertices
         // parent[] --&gt; Stores parent vertices in DFS tree
         void bridgeUtil(int u, boolean visited[], int disc[],
                         int low[], int parent[]) {

             // Mark the current node as visited
             visited[u] = true;

             // Initialize discovery time and low value
             disc[u] = low[u] = ++time;

             // Go through all vertices aadjacent to this
             Iterator&lt;Integer&gt; i = adj[u].iterator();
             while (i.hasNext()) {
                 int v = i.next();  // v is current adjacent of u

                 // If v is not visited yet, then make it a child
                 // of u in DFS tree and recur for it.
                 // If v is not visited yet, then recur for it
                 if (!visited[v]) {
                     parent[v] = u;
                     bridgeUtil(v, visited, disc, low, parent);

                     // Check if the subtree rooted with v has a
                     // connection to one of the ancestors of u
                     low[u] = Math.min(low[u], low[v]);

                     // If the lowest vertex reachable from subtree
                     // under v is below u in DFS tree, then u-v is
<A NAME="1"></A>                     // a bridge
                     if</B></FONT> (low[v] &gt; disc[u]) {
                         res.add(Arrays.asList(v, u));
                     <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match7-1.html#1',3,'match7-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

                 }

                 // Update low value of u for parent function calls.
                 else if (v != parent[u])
                     low[u] = Math.min(low[u], disc[v]);
             }
         }


         // DFS based function to find all bridges. It uses recursive
         // function bridgeUtil()
         void bridge() {
             // Mark all the vertices as not visited
             boolean visited[] = new boolean[V];
             int disc[] = new int[V];
             int low[] = new int[V];
             int parent[] = new int[V];


             // Initialize parent and visited, and ap(articulation point)
             // arrays
             for (int i = 0; i &lt; V; i++) {
                 parent[i] = NIL;
                 visited[i] = false;
             }

             // Call the recursive helper function to find Bridges
             // in DFS tree rooted with vertex 'i'
             for (int i = 0; i &lt; V; i++)
                 if (visited[i] == false)
                     bridgeUtil(i, visited, disc, low, parent);
         }</B></FONT>
     }
<A NAME="2"></A>
     public List&lt;List&lt;Integer&gt;&gt; criticalConnections(int n, List&lt;List&lt;Integer&gt;&gt; connections) {
        Graph graph = new Graph(n);
        <FONT color="#77bfc7"><A HREF="javascript:ZweiFrames('match7-1.html#2',3,'match7-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>for (List&lt;Integer&gt; l : connections) {
            graph.addEdge(l.get(0), l.get(1));
        }
        graph.bridge();
        return res;
     }
}</B></FONT>
</PRE>

</BODY>
</HTML>
