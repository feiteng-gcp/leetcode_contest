<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>325_qingqi_lei.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>325_qingqi_lei.java</CENTER></H3><HR>
<PRE>
class Solution {
    
    private int V;   // No. of vertices 
  
    // Array  of lists for Adjacency List Representation 
    private LinkedList&lt;Integer&gt; adj[]; 
    int time = 0; 
    static final int NIL = -1; 
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();
<A NAME="1"></A>    
    public List&lt;List&lt;Integer&gt;&gt; criticalConnections(int v, List&lt;List&lt;Integer&gt;&gt; connections) {
        V = v;
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match14-0.html#1',2,'match14-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>adj = new LinkedList[v]; 
        for (int i=0; i&lt;v; ++i) 
            adj[i] = new LinkedList(); 
        
        for(List&lt;Integer&gt; list : connections){</B></FONT>
            int start = list.get(0), end = list.get(1);
            
            adj[start].add(end);
            adj[end].add(start);
        }
        bridge();
<A NAME="0"></A>        return res;
    }
    
    <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match14-0.html#0',2,'match14-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>void bridgeUtil(int u, boolean visited[], int disc[], 
                    int low[], int parent[]) 
    { 
  
        // Mark the current node as visited 
        visited[u] = true; 
  
        // Initialize discovery time and low value 
        disc[u] = low[u] = ++time; 
  
        // Go through all vertices aadjacent to this 
        Iterator&lt;Integer&gt; i = adj[u].iterator(); 
        while (i.hasNext()) 
        { 
            int v = i.next();  // v is current adjacent of u 
  
            // If v is not visited yet, then make it a child 
            // of u in DFS tree and recur for it. 
            // If v is not visited yet, then recur for it 
            if (!visited[v]) 
            { 
                parent[v] = u; 
                bridgeUtil(v, visited, disc, low, parent); 
  
                // Check if the subtree rooted with v has a 
                // connection to one of the ancestors of u 
                low[u]  = Math.min(low[u], low[v]); 
  
                // If the lowest vertex reachable from subtree 
                // under v is below u in DFS tree, then u-v is 
                // a bridge 
                if (low[v] &gt; disc[u]) {
                    ArrayList&lt;Integer&gt; tempList = new  ArrayList&lt;&gt;();
                    tempList.add(u);
                    tempList.add(v);
                    res.add(tempList);
                }
                    
            } 
  
            // Update low value of u for parent function calls. 
            else if (v != parent[u]) 
                low[u]  = Math.min(low[u], disc[v]); 
        } 
    } 
  
  
    // DFS based function to find all bridges. It uses recursive 
    // function bridgeUtil() 
<A NAME="2"></A>    void b</B></FONT>ridge() 
    { 
        // Mark all the vertices as not visited 
        <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match14-0.html#2',2,'match14-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>boolean visited[] = new boolean[V]; 
        int disc[] = new int[V]; 
        int low[] = new int[V]; 
        int parent[] = new int[V]; 
  
  
        // Initialize parent and visited, and ap(articulation point) 
        // arrays 
        for (int i = 0; i &lt; V; i++) 
        { 
            parent[i] = NIL; 
            visited[i] = false; 
        } 
  
        // Call the recursive helper function to find Bridges 
        // in DFS tree rooted with vertex 'i' 
        for (int i = 0</B></FONT>; i &lt; V; i++) 
            if (visited[i] == false) 
                bridgeUtil(i, visited, disc, low, parent); 
    } 
}
</PRE>

</BODY>
</HTML>
