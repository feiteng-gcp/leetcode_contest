<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>24_autumn_eel.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>24_autumn_eel.cpp</CENTER></H3><HR>
<PRE>
#include &lt;bits/stdc++.h&gt;
#define rep(i,n)for(int i=0;i&lt;(n);i++)
#define MOD 1000000007
#define INF 0x3f3f3f3f
#define INFL 0x3f3f3f3f3f3f3f3f
#define EPS (1e-10)
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt;P;

#ifdef DEBUG
struct TreeNode{
	int val;
	TreeNode*left;
	TreeNode*right;
	TreeNode(int x):val(x),left(NULL),right(NULL){}
};
#endif

string to_string(string s){return s;}

template&lt;class T&gt;
string to_string(vector&lt;T&gt;v){
	string res;
	res+=&quot;{&quot;;
	rep(i,v.size()){
		if(i)res+=&quot;,&quot;;
		res+=to_string(v[i]);
	}
	res+=&quot;}&quot;;
	return res;
}

template&lt;class T&gt;
ostream&amp;operator&lt;&lt;(ostream&amp;os,vector&lt;T&gt;v){
	cout&lt;&lt;to_string(v);
	return os;
}

ostream&amp;operator&lt;&lt;(ostream&amp;os,TreeNode*t){
	map&lt;int,int&gt;mp;
	function&lt;void(TreeNode*,int)&gt;dfs=[&amp;](TreeNode*t,int k){
		if(!t)return;
		mp[k]=t-&gt;val;
		dfs(t-&gt;left,k*2+1);
		dfs(t-&gt;right,k*2+2);
	};
	dfs(t,0);
	int Max=0;
	for(auto p:mp)Max=max(Max,p.first);
	vector&lt;string&gt;ans(Max+1,&quot;null&quot;);
	for(auto p:mp)ans[p.first]=to_string(p.second);
	os&lt;&lt;ans;
	return os;
}

template&lt; unsigned mod &gt;
struct RollingHash {
  vector&lt; unsigned &gt; hashed, power;

  inline unsigned mul(unsigned a, unsigned b) const {
	  return a*(unsigned long long)b%mod;
  }

  RollingHash(const string &amp;s, unsigned base = 10007) {
    int sz = (int) s.size();
    hashed.assign(sz + 1, 0);
    power.assign(sz + 1, 0);
    power[0] = 1;
    for(int i = 0; i &lt; sz; i++) {
      power[i + 1] = mul(power[i], base);
      hashed[i + 1] = mul(hashed[i], base) + s[i];
      if(hashed[i + 1] &gt;= mod) hashed[i + 1] -= mod;
    }
  }

  unsigned get(int l, int r) const {
    unsigned ret = hashed[r] + mod - mul(hashed[l], power[r - l]);
    if(ret &gt;= mod) ret -= mod;
    return ret;
  }

  unsigned connect(unsigned h1, int h2, int h2len) const {
    unsigned ret = mul(h1, power[h2len]) + h2;
    if(ret &gt;= mod) ret -= mod;
<A NAME="0"></A>    return ret;
  }

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match33-0.html#0',2,'match33-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  int LCP(const RollingHash&lt; mod &gt; &amp;b, int l1, int r1, int l2, int r2) {
    int len = min(r1 - l1, r2 - l2);
    int low = -1, high = len + 1;
    while(high - low &gt; 1) {
      int mid = (low + high) / 2;
      if(get(l1, l1 + mid) == b.get(l2, l2 + mid)) low = mid;
      else high = mid;
    }
    return (low);
  }
};</B></FONT>

class Solution {
public:
    string longestDupSubstring(string S) {
		RollingHash&lt;1000000007&gt; RH(S);
		RollingHash&lt;998244353&gt; RH2(S);
        int ok=0,ng=S.size();
        while(ng-ok&gt;1){
			int t=(ok+ng)/2;
			map&lt;pair&lt;unsigned,unsigned&gt;,int&gt;mp;
			bool flag=false;
			rep(i,S.size()-t+1){
				uint res=RH.get(i,i+t),res2=RH2.get(i,i+t);
				if(mp[{res,res2}]){flag=true;break;}
				else mp[{res,res2}]++;
			}
			if(flag)ok=t;
			else ng=t;
		}
		//~ cout&lt;&lt;RH.get(1,3)&lt;&lt;' '&lt;&lt;RH2.get(1,3)&lt;&lt;endl;
		//~ cout&lt;&lt;RH.get(3,5)&lt;&lt;' '&lt;&lt;RH2.get(3,5)&lt;&lt;endl;
		if(ok==0)return &quot;&quot;;
		map&lt;pair&lt;unsigned,unsigned&gt;,int&gt;mp;
		rep(i,S.size()-ok+1){
			uint res=RH.get(i,i+ok),res2=RH2.get(i,i+ok);
			if(mp[{res,res2}]){
				return S.substr(i,ok);
			}
			else mp[{res,res2}]++;
		}
		return &quot;&quot;;
    }
};

#ifdef DEBUG
int main(){
	Solution sol;
	auto res=sol.longestDupSubstring(&quot;banana&quot;);
	cout&lt;&lt;res&lt;&lt;endl;
}
#endif
</PRE>
</BODY>
</HTML>
