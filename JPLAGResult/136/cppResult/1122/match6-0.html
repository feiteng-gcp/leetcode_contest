<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>7_wjli.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>7_wjli.cpp</CENTER></H3><HR>
<PRE>


// always append &quot;$&quot; to the end or otherwise the library will have error

// CP3: Suffix Array

#define MAX_N 300050 // second approach: O(n log n)

int RA[MAX_N], tempRA[MAX_N]; // rank array and temporary rank array
int SA[MAX_N], tempSA[MAX_N]; // suffix array and temporary suffix array. SA[i] = starting position of i-th suffix in lexicographical order
int RSA[MAX_N]; // RSA[i]: the i-th suffix is in the RSA[i]-ith lexicographically smallest suffix
int c[MAX_N]; // for counting/radix sort
int Phi[MAX_N], LCP[MAX_N], PLCP[MAX_N]; // for LCP counting

<A NAME="0"></A>class suffix_array {
public:
	string T; // the input string, up to MAX_N characters
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match6-1.html#0',3,'match6-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	int n; // the length of input string


	void countingSort(int k) { // O(n)
		int i, sum, maxi = max(300, n); // up to 255 ASCII chars or length of n
		memset(c, 0, sizeof c); // clear frequency table
		for (i = 0; i &lt; n; i++) // count the frequency of each integer rank
			c[i + k &lt; n ? RA[i + k] : 0]++;
		for (i = sum = 0; i &lt; maxi; i++) {
			int t = c[i]; c[i] = sum; sum += t;
		}
		for (i = 0; i &lt; n; i++) // shuffle the suffix array if necessary
			tempSA[c[SA[i] + k &lt; n ? RA[SA[i] + k] : 0]++] = SA[i];
		for (i = 0; i &lt; n; i++) // update the suffix array SA
			SA[i] = tempSA[i];
	}

	void constructSA(string s) { // this version can go up to 100000 characters
<A NAME="1"></A>		int i, k, r;</B></FONT>
		T = s;
		n = s.length();
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match6-1.html#1',3,'match6-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		for (i = 0; i &lt; n; i++) RA[i] = T[i]; // initial rankings
		for (i = 0; i &lt; n; i++) SA[i] = i; // initial SA: {0, 1, 2, ..., n-1}
		for (k = 1; k &lt; n; k &lt;&lt;= 1) { // repeat sorting process log n times
			countingSort(k); // actually radix sort: sort based on the second item
			countingSort(0); // then (stable) sort based on the first item
			tempRA[SA[0]] = r = 0; // re-ranking; start from rank r = 0
			for (i = 1; i &lt; n; i++) // compare adjacent suffixes
				tempRA[SA[i]] = // if same pair =&gt; same rank r; otherwise, increase r
				(RA[SA[i]] == RA[SA[i - 1]] &amp;&amp; RA[SA[i] + k] == RA[SA[i - 1] + k]) ? r : ++r;
			for (i = 0; i &lt; n; i++) // update the rank array RA
				RA[i] = tempRA[i];
			if (RA[SA[n - 1]] == n - 1) break; // nice optimization trick
		}
	}

	void computeLCP() {
		int i, L;
		Phi[SA[0]] = -1; // default value
		for (i = 1; i &lt; n; i++) // compute Phi in O(n)
			Phi[SA[i]] = SA[i - 1]; // remember which suffix is behind this suffix
		for (i = L = 0; i &lt; n; i++) { // compute Permuted LCP in O(n)
			if (Phi[i] == -1) { PLCP[i] = 0; continue; } // special case
			while (T[i + L] == T[Phi[i] + L]) L++; // L increased max n times
			PLCP[i] = L;
			L = max(L - 1, 0); // L decreased max n times
		}
		for (i = 0; i &lt; n; i++) // compute LCP in O(n)
			LCP[i] = PLCP[SA[i]]; // put the permuted LCP to the correct position
	}</B></FONT>

	void buildReverseSA() {
		int i;
		for (i = 0; i &lt; n; i++) RSA[SA[i]] = i;
	}
};


class Solution {
public:
	string longestDupSubstring(string S) {
		S = S + &quot;$&quot;;

		suffix_array sa;
		sa.constructSA(S);
		sa.computeLCP();
		sa.buildReverseSA();

		int i, j, k, n = S.length(), maxx = -1, p;

		for (i = 0; i &lt; n; i++) {
			if (LCP[i] &gt; maxx) {
				maxx = LCP[i];
				p = i;
			}
		}

		string ans;
		if (maxx == 0) ans = &quot;&quot;;
		else ans = S.substr(SA[p], maxx);

		return ans;
	}
};
</PRE>
</BODY>
</HTML>
