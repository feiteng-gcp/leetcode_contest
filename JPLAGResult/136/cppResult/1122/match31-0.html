<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>25_hamayanhamayan.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>25_hamayanhamayan.cpp</CENTER></H3><HR>
<PRE>
#include&lt;bits/stdc++.h&gt;
#define rep(i,a,b) for(int i=a;i&lt;b;i++)
#define rrep(i,a,b) for(int i=a;i&gt;=b;i--)
#define fore(i,a) for(auto &amp;i:a)
#define all(x) (x).begin(),(x).end()
//#pragma GCC optimize (&quot;-O3&quot;)
using namespace std;
typedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL &lt;&lt; 60;
template&lt;class T&gt;bool chmax(T&amp; a, const T&amp; b) { if (a &lt; b) { a = b; return 1; } return 0; }
template&lt;class T&gt;bool chmin(T&amp; a, const T&amp; b) { if (b &lt; a) { a = b; return 1; } return 0; }
//---------------------------------------------------------------------------------------------------
#ifdef _MSC_VER
inline unsigned int __builtin_clz(unsigned int x){unsigned long r;_BitScanReverse(&amp;r,x);return 31-r;}
#endif // _MSC_VER
template&lt;class V&gt; struct SparseTable { // [L,R)
    const V def = 0;
    inline V comp(V a, V b) { return min(a,b); }

    int n; vector&lt;V&gt; a, b[20]; inline int __lg(int x) { return 32 - 1 - __builtin_clz(x); }
    void init(vector&lt;V&gt; v) {
        int nn = v.size(); n = 1; while (n &lt; nn) n *= 2; a.resize(n);
        rep(i, 0, 20) b[i].resize(n); rep(i, 0, nn) a[i] = v[i];

<A NAME="0"></A>        int d = 1 &lt;&lt; __lg(n - 1), e = d &lt;&lt; 1;
        for (int h = 0, f; (f = 1 &lt;&lt; h) &lt;= d; ++h) {
            for (int i = f, r = f &lt;&lt; 1; i &lt; e; i += r) {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match31-1.html#0',3,'match31-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>                b[h][i - 1] = a[i - 1];
                for (int j = i - 2; j &gt;= i - f; --j) b[h][j] = comp(b[h][j + 1], a[j]);
                b[h][i] = a[i];
                for (int j = i + 1; j &lt; i + f; ++j) b[h][j] = comp(b[h][j - 1], a[j]);</B></FONT>
            }
        }
    }

    V get(int L,int R){assert(0&lt;=L&amp;&amp;L&lt;=R);if(L==R)return def;R--;if(L==R)return a[L];int h=__lg(L^R);
        return comp(b[h][L],b[h][R]);}};
struct SAIS {
    vector&lt;int&gt; sa, lcp, rank;
    SAIS() {}
    SAIS(string str_) : str(str_) {
        N = str.size() + 1;
        S = vector&lt;int&gt;(N, 0);
        for (int i = 0; i&lt;N; i++) S[i] = str[i];
        *this = SAIS(S, 256);
    }
    SAIS(const vector&lt;int&gt; &amp;S_, int A_SIZE_, bool lcp_flag = true) : S(S_), A_SIZE(A_SIZE_) {
        buildSA();
        if (lcp_flag) buildLCP();
    }
    void load(string str_) {
        str = str_;
        N = str.size() + 1;
        S = vector&lt;int&gt;(N, 0);
        for (int i = 0; i&lt;N; i++) S[i] = str[i];
        *this = SAIS(S, 256);
    }
    string str;
    vector&lt;int&gt; S;
    int A_SIZE;
    int N;
    vector&lt;int&gt; t, B;
    enum { STYPE, LTYPE };

    inline bool is_lms(int i) {
        return i&gt;0 &amp;&amp; t[i] == STYPE &amp;&amp; t[i - 1] == LTYPE;
    }
    void bucket() {
        B = vector&lt;int&gt;(A_SIZE);
        for (int i = 0; i&lt;N; i++) B[S[i]]++;
        for (int i = 0; i&lt;A_SIZE - 1; i++) B[i + 1] += B[i];
    }
    void induced_sort() {
        bucket();
        for (int i = 0; i&lt;N; i++) {
            int j = sa[i] - 1;
            if (j &gt;= 0 &amp;&amp; S[j] &gt;= S[j + 1]) sa[B[S[j] - 1]++] = j;
        }
        bucket();
        for (int i = N; i--; ) {
            int j = sa[i] - 1;
            if (j &gt;= 0 &amp;&amp; S[j] &lt;= S[j + 1]) sa[--B[S[j]]] = j;
        }
    }
    void buildSA() {
        N = S.size();
        sa.assign(N, -1);
        if (N == 1) {
            sa[0] = 0;
            return;
        }
        t.assign(N, STYPE);
        for (int i = N - 1; i--;)
            if (S[i] &gt; S[i + 1] || (S[i] == S[i + 1] &amp;&amp; t[i + 1] == LTYPE))
                t[i] = LTYPE;
        bucket();
        for (int i = N; i--;)
            if (is_lms(i)) sa[--B[S[i]]] = i;
<A NAME="1"></A>        induced_sort();

        int N1 = 0;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match31-1.html#1',3,'match31-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        for (int i = 0; i&lt;N; i++) if (is_lms(sa[i])) sa[N1++] = sa[i];

        fill(sa.begin() + N1, sa.end(), -1);
        int name = 0, prev = -1;
        for (int i = 0; i&lt;N1; i++) {
            int cur = sa[i];</B></FONT>
            bool diff = (prev == -1);
            for (int j = 0; !diff; j++) {
                if (j&gt;0 &amp;&amp; is_lms(cur + j)) break;
                if (S[cur + j] != S[prev + j]) diff = true;
            }
            if (diff) name++;
            sa[N1 + cur / 2] = name - 1;
            prev = cur;
        }
        vector&lt;int&gt; S1, sa1(N1);
        for (int i = N1; i&lt;N; i++) if (sa[i] &gt;= 0) S1.push_back(sa[i]);
        if (name == N1) for (int i = 0; i&lt;N1; i++) sa1[S1[i]] = i;
        else sa1 = SAIS(S1, name, false).sa;

        N1 = 0;
        for (int i = 0; i&lt;N; i++) if (is_lms(i)) S1[N1++] = i;
        for (int i = 0; i&lt;N1; i++) sa1[i] = S1[sa1[i]];

        fill(sa.begin(), sa.end(), -1);
        bucket();
        for (int i = N1; i--;) {
            int j = sa1[i];
            sa[--B[S[j]]] = j;
        }
        induced_sort();
    }
    void buildLCP() {
        rank.resize(N);
        lcp.resize(N - 1);
        for (int i = 0; i&lt;N; i++) rank[sa[i]] = i;
        int h = 0;
        for (int i = 0; i&lt;N - 1; i++) {
            int j = sa[rank[i] - 1];
            if (h&gt;0) h--;
            for (; j + h&lt;N &amp;&amp; i + h&lt;N &amp;&amp; S[j + h] == S[i + h]; h++);
            lcp[rank[i] - 1] = h;
        }
    }


	void build() {
		buildSA();
		buildLCP();
	}
};
SAIS sais;
SparseTable&lt;int&gt; rmq;
void buildRMQ() {
	rmq.init(sais.lcp);
}
int common_prefix(int x, int y) {
	if (x == y) return sais.N - 1 - x;
	if (y &gt;= sais.N - 1) return 0;
	if (sais.rank[x] &gt; sais.rank[y]) swap(x, y);
	return rmq.get(sais.rank[x], sais.rank[y]);
}
int compare(int x, int xn, int y, int yn) {
	int l = common_prefix(x, y);
	if (l &gt;= xn || l &gt;= yn) return xn &lt; yn ? -1 : xn == yn ? 0 : 1;
	return sais.rank[x] &lt; sais.rank[y] ? -1 : x == y ? 0 : 1;
}
/*---------------------------------------------------------------------------------------------------
　　　　　　　　　　　 ∧＿∧
　　　　　 ∧＿∧ 　（´&lt;_｀ ）　 Welcome to My Coding Space!
　　　　 （ ´_ゝ`）　/　 ⌒i
　　　　／　　　＼　 　  |　|
　　　 /　　 /￣￣￣￣/　　|
　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿
　 　　　＼/＿＿＿＿/　（u　⊃
---------------------------------------------------------------------------------------------------*/
class Solution {
public:
	string longestDupSubstring(string S) {
		sais.load(S);
		buildRMQ();
		sais.build();

		int N = S.length();
		int ma = 0, idx = -1;
		rep(i, 0, N) {
			int len = common_prefix(sais.sa[i], sais.sa[i + 1]);
			if (ma &lt; len) {
				ma = len;
				idx = sais.sa[i];
			}
		}

		if (ma == 0) return &quot;&quot;;
		return S.substr(idx, ma);
	}
};
</PRE>
</BODY>
</HTML>
