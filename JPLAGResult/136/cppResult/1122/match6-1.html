<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>6_maxhwardg.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>6_maxhwardg.cpp</CENTER></H3><HR>
<PRE>
#include &lt;bits/stdc++.h&gt;

using namespace std;

template &lt;typename T&gt;
using V = vector&lt;T&gt;;

typedef long double ld;
typedef long long ll;

#define FO(i, N) for (int (i) = 0; (i) &lt; (N); ++(i))
#define FOll(i, N) for (ll (i) = 0; (i) &lt; (N); ++(i))
#define READALL(c) for (auto &amp;e : c) { cin &gt;&gt; e; }
#define PRINTALL(c) for (const auto &amp;e : c) { cout &lt;&lt; e &lt;&lt; &quot; &quot;; } cout &lt;&lt; &quot;\n&quot;;
#define MP(x, y) (make_pair((x), (y)))
#define MT(...) make_tuple(__VA_ARGS__)
#define ALL(x) begin(x), end(x)

#define MAX_N 100010                       // second approach: O(n log n)
string T;                   // the input string, up to 100K characters
int n;                                        // the length of input string
int RA[MAX_N], tempRA[MAX_N];        // rank array and temporary rank array
int SA[MAX_N], tempSA[MAX_N];    // suffix array and temporary suffix array
int c[MAX_N];                                    // for counting/radix sort

string P;                  // the pattern string (for string matching)
int m;                                      // the length of pattern string
<A NAME="0"></A>
int Phi[MAX_N];                      // for computing longest common prefix
int PLCP[MAX_N];
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match6-0.html#0',2,'match6-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int LCP[MAX_N];  // LCP[i] stores the LCP between previous suffix T+SA[i-1]
                                              // and current suffix T+SA[i]
void countingSort(int k) {                                          // O(n)
  int i, sum, maxi = max(300, n);   // up to 255 ASCII chars or length of n
  memset(c, 0, sizeof c);                          // clear frequency table
  for (i = 0; i &lt; n; i++)       // count the frequency of each integer rank
    c[i + k &lt; n ? RA[i + k] : 0]++;
  for (i = sum = 0; i &lt; maxi; i++) {
    int t = c[i]; c[i] = sum; sum += t;
  }
  for (i = 0; i &lt; n; i++)          // shuffle the suffix array if necessary
    tempSA[c[SA[i]+k &lt; n ? RA[SA[i]+k] : 0]++] = SA[i];
  for (i = 0; i &lt; n; i++)                     // update the suffix array SA
    SA[i] = tempSA[i];
<A NAME="1"></A>}
void constructSA() {         // this version can go up to 100000 characters
  int i, k, r;</B></FONT>
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match6-0.html#1',2,'match6-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  for (i = 0; i &lt; n; i++) RA[i] = T[i];                 // initial rankings
  for (i = 0; i &lt; n; i++) SA[i] = i;     // initial SA: {0, 1, 2, ..., n-1}
  for (k = 1; k &lt; n; k &lt;&lt;= 1) {       // repeat sorting process log n times
    countingSort(k);  // actually radix sort: sort based on the second item
    countingSort(0);          // then (stable) sort based on the first item
    tempRA[SA[0]] = r = 0;             // re-ranking; start from rank r = 0
    for (i = 1; i &lt; n; i++)                    // compare adjacent suffixes
      tempRA[SA[i]] = // if same pair =&gt; same rank r; otherwise, increase r
      (RA[SA[i]] == RA[SA[i-1]] &amp;&amp; RA[SA[i]+k] == RA[SA[i-1]+k]) ? r : ++r;
    for (i = 0; i &lt; n; i++)                     // update the rank array RA
      RA[i] = tempRA[i];
    if (RA[SA[n-1]] == n-1) break;               // nice optimization trick
} }
void computeLCP() {
  int i, L;
  Phi[SA[0]] = -1;                                         // default value
  for (i = 1; i &lt; n; i++)                            // compute Phi in O(n)
    Phi[SA[i]] = SA[i-1];    // remember which suffix is behind this suffix
  for (i = L = 0; i &lt; n; i++) {             // compute Permuted LCP in O(n)
    if (Phi[i] == -1) { PLCP[i] = 0; continue; }            // special case
    while (T[i + L] == T[Phi[i] + L]) L++;       // L increased max n times
    PLCP[i] = L;
    L = max(L-1, 0);                             // L decreased max n times
  }
  for (i = 0; i &lt; n; i++)                            // compute LCP in O(n)
    LCP[i] = PLCP[SA[i]];   // put the permuted LCP to the correct position
}</B></FONT>
int owner(int idx) { return (idx &lt; n-m-1) ? 1 : 2; }
pair&lt;int, int&gt; LCS() {      // returns a pair (the LCS length and its index)
  int i, idx = 0, maxLCP = -1;
  for (i = 1; i &lt; n; i++)                         // O(n), start from i = 1
    if (owner(SA[i]) != owner(SA[i-1]) &amp;&amp; LCP[i] &gt; maxLCP)
      maxLCP = LCP[i], idx = i;
  return make_pair(maxLCP, idx);
}

class Solution {
public:
    string longestDupSubstring(string S) {
        T=S+&quot;$&quot;;
        n=T.size();
        constructSA();
        computeLCP();
        int ans=-1, maxi=-1;
        for (int i=0;i&lt;T.size();++i) {
        	// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; LCP[i] &lt;&lt; &quot; &quot; &lt;&lt; T.substr(SA[i]) &lt;&lt; endl;
        	if (LCP[i]&gt;ans) {
        		ans=LCP[i];
        		maxi=i;
        	}
        }
        if (maxi==-1) return &quot;&quot;;
        return T.substr(SA[maxi], LCP[maxi]);
    }
};
</PRE>
</BODY>
</HTML>
