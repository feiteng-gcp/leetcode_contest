<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>255_gracious.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>255_gracious.cpp</CENTER></H3><HR>
<PRE>
<A NAME="0"></A><FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match3-0.html#0',2,'match3-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>class Solution {
public:
    vector&lt;int&gt; pre;
    int find(int x){
        return pre[x]&lt;0?x:pre[x]=find(pre[x]);
    }
    
    void merge( int x,int y ){
        x = find(x);
        y = find(y);
        if ( x==y ) return;
        pre[x]+=pre[y];
        pre[y]=x;
    }
    
    unordered_map&lt;int,vector&lt;int&gt;&gt; mp;
    bool vis[10000]={false};
    int dp[200][200]={0};
    int findTheCity(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int distanceThreshold) {
        for ( int i=0; i&lt;n; ++i )
            for ( int j=0; j&lt;n; ++j )
                if ( i!=j )
                    dp[i][j] = 0x3f3f3f3f;
        // for ( auto &amp;e:edges ){
        //     mp[e[0]].push_back(e[1]);
        //     mp[e[1]].push_back(e[0]);
        // }
        for ( auto &amp;e:edges ){
            dp[e[0]][e[1]] = e[2];
            dp[e[1]][e[0]] = e[2];
        }
        
        for ( int i=0; i&lt;n; ++i ){
            for ( int j=0; j&lt;n; ++j ){
                for ( int k=0; k&lt;n; ++k ){
                    dp[j][k] = min( dp[j][i]+dp[i][k], dp[j][k] );
                }       
            }
        }
        // for ( auto &amp;e:edges ){
        //     merge( e[0], e[1] );
        //     if ( e[2]&gt; distanceThreshold )
        //         continue;
        //     dp[e[0]]+=e[2];
        //     dp[e[1]]+=e[2];
        // }
        
        int res = -1, mini = INT_MAX, maxi=0;
        for ( int i=n-1; i&gt;=0; --i ){
            int z=0, w=0;
            for ( int j=0; j&lt;n; ++j ){
                if ( i!=j &amp;&amp; dp[i][j]&lt;0x3f3f3f3f ){
                    if ( dp[i][j]&lt;=distanceThreshold ){
                        ++z;
                        w += dp[i][j];
                    }
                } 
            }
            // 可达城市
            if ( mini&gt;z ){
                mini = z;
                maxi = w;
                res = i;
            }
        }
        return res;
    }
};</B></FONT>
</PRE>
</BODY>
</HTML>
