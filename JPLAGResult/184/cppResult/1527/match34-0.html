<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>399_tomarint.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>399_tomarint.cpp</CENTER></H3><HR>
<PRE>
#define DEBUG 1
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;deque&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;numeric&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
using namespace std;
using ll = long long;
using ull = unsigned long long;
using ld = long double;
using vll = vector&lt;ll&gt;;
using vvll = vector&lt;vll&gt;;
using pll = pair&lt;ll, ll&gt;;
using vpll = vector&lt;pll&gt;;
using vvpll = vector&lt;vpll&gt;;
using tll = tuple&lt;ll, ll, ll&gt;;
using vtll = vector&lt;tll&gt;;
using vvtll = vector&lt;vtll&gt;;
#define all(v) (v).begin(), (v).end()
#define for1(i, n) for (ll i = 0; i &lt; (n); i++)
#define for2(i, m, n) for (ll i = (m); i &lt; (n); i++)
#define for3(i, m, n, d) for (ll i = (m); i &lt; (n); i += (d))
#define rfor2(i, m, n) for (ll i = (m); i &gt; (n); i--)
#define rfor3(i, m, n, d) for (ll i = (m); i &gt; (n); i += (d))
#define PI 3.1415926535897932384626433832795028841971693993751L
#define INF 1111111111111111111LL
#define print(...) print_1(__VA_ARGS__)
#define in(...) in_1(__VA_ARGS__)
#if DEBUG
#define dump(...) dump_1(#__VA_ARGS__, __VA_ARGS__)
#define dumpa(...) dumpa_1(#__VA_ARGS__, __VA_ARGS__)
#else
#define dump(...)
#define dumpa(...)
#endif
template &lt;typename Head&gt;
void dump_1(const char* str, Head&amp;&amp; h)
{
    cerr &lt;&lt; str &lt;&lt; &quot;: &quot; &lt;&lt; h &lt;&lt; '\n';
}
template &lt;typename Head, typename... Tail&gt;
void dump_1(const char* str, Head&amp;&amp; h, Tail&amp;&amp;... t)
{
    while (*str != ',') {
        cerr &lt;&lt; *str++;
    }
    cerr &lt;&lt; &quot;: &quot; &lt;&lt; h &lt;&lt; ' ';
    dump_1(str + 1, t...);
}
template &lt;typename T&gt;
void dumpa_1(const char* str, const T v[], const ll size)
{
    while (*str != ',') {
        cerr &lt;&lt; *str++;
    }
    cerr &lt;&lt; &quot;: &quot;;
    for1 (i, size) {
        if (i != 0) {
            cerr &lt;&lt; ' ';
        }
        cerr &lt;&lt; v[i];
    }
    cerr &lt;&lt; '\n';
}
template &lt;typename T1, typename T2&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const pair&lt;T1, T2&gt;&amp; v)
{
    os &lt;&lt; v.first &lt;&lt; ' ' &lt;&lt; v.second;
    return os;
}
template &lt;typename T1, typename T2, typename T3&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const tuple&lt;T1, T2, T3&gt;&amp; v)
{
    os &lt;&lt; get&lt;0&gt;(v) &lt;&lt; ' ' &lt;&lt; get&lt;1&gt;(v) &lt;&lt; ' ' &lt;&lt; get&lt;2&gt;(v);
    return os;
}
template &lt;typename T&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const vector&lt;T&gt;&amp; v)
{
    for (auto it = v.begin(); it != v.end(); it++) {
        if (it != v.begin()) {
            os &lt;&lt; ' ';
        }
        os &lt;&lt; *it;
    }
    return os;
}
template &lt;typename T&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const set&lt;T&gt;&amp; v)
{
    for (auto it = v.begin(); it != v.end(); it++) {
        if (it != v.begin()) {
            os &lt;&lt; ' ';
        }
        os &lt;&lt; *it;
    }
    return os;
}
template &lt;typename T&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const multiset&lt;T&gt;&amp; v)
{
    for (auto it = v.begin(); it != v.end(); it++) {
        if (it != v.begin()) {
            os &lt;&lt; ' ';
        }
        os &lt;&lt; *it;
    }
    return os;
}
template &lt;typename T1, typename T2&gt;
ostream&amp; operator&lt;&lt;(ostream&amp; os, const map&lt;T1, T2&gt;&amp; v)
{
    os &lt;&lt; '{';
    for (auto it = v.begin(); it != v.end(); it++) {
        if (it != v.begin()) {
            os &lt;&lt; &quot;, &quot;;
        }
        os &lt;&lt; it-&gt;first &lt;&lt; ':' &lt;&lt; it-&gt;second;
    }
    os &lt;&lt; '}';
    return os;
}
ll divup(ll nume, ll deno)
{
    assert(nume &gt;= 0);
    assert(deno &gt; 0);
    return (nume + deno - 1) / deno;
}
void Yes(void) { cout &lt;&lt; &quot;Yes\n&quot;; }
void No(void) { cout &lt;&lt; &quot;No\n&quot;; }
void YES(void) { cout &lt;&lt; &quot;YES\n&quot;; }
void NO(void) { cout &lt;&lt; &quot;NO\n&quot;; }
template &lt;typename T&gt;
bool chmax(T&amp; a, const T&amp; b)
{
    if (a &lt; b) {
        a = b;
        return true;
    }
    return false;
}
template &lt;typename T&gt;
bool chmin(T&amp; a, const T&amp; b)
{
    if (a &gt; b) {
        a = b;
        return true;
    }
    return false;
}
template &lt;typename T&gt;
void vin(vector&lt;T&gt;&amp; v)
{
    ll len = v.size();
    for1 (i, len) {
        cin &gt;&gt; v[i];
    }
}
template &lt;typename Head&gt;
void in_1(Head&amp; h)
{
    cin &gt;&gt; h;
}
template &lt;typename Head, typename... Tail&gt;
void in_1(Head&amp; h, Tail&amp;... t)
{
    cin &gt;&gt; h;
    in_1(t...);
}
template &lt;typename Head&gt;
void print_1(Head&amp;&amp; h)
{
    cout &lt;&lt; h &lt;&lt; '\n';
}
template &lt;typename Head, typename... Tail&gt;
void print_1(Head&amp;&amp; h, Tail&amp;&amp;... t)
{
    cout &lt;&lt; h &lt;&lt; ' ';
    print_1(t...);
}
//---------------------------------------------------------
const ll mod = 1000000007LL;  // 10**9 + 7
struct mint {
    ll x;  // typedef long long ll;
    mint(ll x = 0) : x((x % mod + mod) % mod) {}
    mint&amp; operator+=(const mint a)
    {
        if ((x += a.x) &gt;= mod) x -= mod;
        return *this;
    }
    mint&amp; operator-=(const mint a)
    {
        if ((x += mod - a.x) &gt;= mod) x -= mod;
        return *this;
    }
    mint&amp; operator*=(const mint a)
    {
        (x *= a.x) %= mod;
        return *this;
    }
    mint operator+(const mint a) const
    {
        mint res(*this);
        return res += a;
    }
    mint operator-(const mint a) const
    {
        mint res(*this);
        return res -= a;
    }
    mint operator*(const mint a) const
    {
        mint res(*this);
        return res *= a;
    }
    mint pow(ll t) const
    {
        if (!t) return 1;
        mint a = pow(t &gt;&gt; 1);
        a *= a;
        if (t &amp; 1) a *= *this;
        return a;
    }

    // for prime mod
    mint inv() const { return pow(mod - 2); }
    mint&amp; operator/=(const mint a) { return (*this) *= a.inv(); }
    mint operator/(const mint a) const
    {
        mint res(*this);
        return res /= a;
    }
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const mint&amp; v)
    {
        os &lt;&lt; v.x;
        return os;
    }
};
//---------------------------------------------------------
struct mintcomb {
    vector&lt;mint&gt; fact, ifact;
    mintcomb(int n) : fact(n + 1), ifact(n + 1)
    {
        assert(n &lt; mod);
        fact[0] = 1;
        for (int i = 1; i &lt;= n; ++i) {
            fact[i] = fact[i - 1] * i;
        }
        ifact[n] = fact[n].inv();
        for (int i = n; i &gt;= 1; --i) {
            ifact[i - 1] = ifact[i] * i;
        }
    }
    mint permutation(int n, int k)
    {
        if (k &lt; 0 || k &gt; n) return 0;
        return fact[n] * ifact[n - k];
    }
    mint combination(int n, int k)
    {
        if (k &lt; 0 || k &gt; n) return 0;
        return fact[n] * ifact[k] * ifact[n - k];
    }
};
//---------------------------------------------------------
class Solution {
<A NAME="0"></A>public:
    int numOfWays(int n)
    {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match34-1.html#0',3,'match34-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        int pos[12][3] = {
            {0, 1, 0}, {0, 1, 2}, {0, 2, 0}, {0, 2, 1}, {1, 0, 1}, {1, 0, 2},
<A NAME="1"></A>            {1, 2, 0}, {1, 2, 1}, {2, 0, 1}, {2, 0, 2}, {2, 1, 0}, {2, 1, 2},
        };</B></FONT>
        bool ok[12][12] = {false};
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match34-1.html#1',3,'match34-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        for (int i = 0; i &lt; 12; ++i) {
            for (int j = 0; j &lt; 12; ++j) {
                bool ok1 = true;
                for (int k = 0; k &lt; 3; ++k) {
                    if (pos[i][k] == pos[j][k]) {
                        ok1 = false;
                        break;
                    }
                }
                ok[i][j] = ok1;
            }
        }</B></FONT>

        mint dp[2][12];

        ll i1 = 1;
        ll i2 = 0;
        for (int i = 0; i &lt; 12; ++i) {
            dp[i2][i] = 1;
        }
<A NAME="2"></A>        for (int i = 1; i &lt; n; ++i) {
            i1 ^= 1;
            i2 ^= 1;
<FONT color="#77bfc7"><A HREF="javascript:ZweiFrames('match34-1.html#2',3,'match34-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>            for (int j = 0; j &lt; 12; ++j) {
                dp[i2][j] = 0;
            }
            for (int j = 0; j &lt; 12; ++j) {
                for (int k = 0; k &lt; 12; ++k) {</B></FONT>
                    if (ok[k][j]) {
                        dp[i2][j] += dp[i1][k];
                    }
                }
            }
        }
        mint ans = 0;
        for (int i = 0; i &lt; 12; ++i) {
            ans += dp[i2][i];
        }
        return (int)ans.x;
    }
};
</PRE>
</BODY>
</HTML>
