<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>436_rkumarr.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>436_rkumarr.cpp</CENTER></H3><HR>
<PRE>
using coor = pair&lt;int, int&gt;;
class config{
    public:
        int i; coor f1; coor f2;
        config(int _i, coor _f1, coor _f2):i(_i), f1(_f1), f2(_f2){}
        bool operator==(const config&amp; c) const {
            return (i==c.i)&amp;&amp;(f1==c.f1)&amp;&amp;(f2==c.f2);
        }
    
};
namespace std{
    template&lt;&gt;
    struct hash&lt;config&gt;{
        size_t operator()(const config&amp; c) const {
             return (hash&lt;int&gt;()(c.i)^0x58927592)^
             (hash&lt;int&gt;()(c.f1.first)^0x89574979)^
             (hash&lt;int&gt;()(c.f1.second)^0x20583048)^
             (hash&lt;int&gt;()(c.f2.first)^0x295947281)^
             (hash&lt;int&gt;()(c.f2.second)^0xF938E8497);
        }
    };
}
class Solution {
public:
    static map&lt;char, coor&gt; kb;
    string word;
    int dist(coor c1, coor c2){
        if((c1.first == -1)&amp;&amp;(c1.second==-1)) return 0;
        return (abs(c1.first - c2.first) + abs(c1.second - c2.second));
    }
    unordered_map&lt;config, int&gt; c;
    int dp(int i, coor f1, coor f2){
        config co = config(i, f1, f2);
        if(c.find(co)!=c.end()) return c[co];
        //cout&lt;&lt;&quot;dp(&quot;&lt;&lt;i&lt;&lt;&quot;)&quot;&lt;&lt;&quot;f1 = (&quot;&lt;&lt;f1.first&lt;&lt;&quot;, &quot;&lt;&lt;f1.second&lt;&lt;&quot;)&quot;&lt;&lt;&quot;; f2 = (&quot;&lt;&lt;
            //f2.first&lt;&lt;&quot;, &quot;&lt;&lt;f2.second&lt;&lt;&quot;)&quot;&lt;&lt;&quot;; word[i]&quot;&lt;&lt;word[i]&lt;&lt;&quot;kb[word[i]] = &quot;&lt;&lt;
            //kb[word[i]].first&lt;&lt;&quot;, &quot;&lt;&lt;kb[word[i]].second&lt;&lt;endl;
        if(i&gt;=word.size()) {
            c[co] = 0;
            return 0;
        }
        int res = numeric_limits&lt;int&gt;::max();
        res = min(dp(i+1, kb[word[i]], f2)+dist(f1, kb[word[i]]), dp(i+1, f1, kb[word[i]])+dist(f2, kb[word[i]]));
        c[co] = res;
        return res;
    }
    int minimumDistance(string word) {
        this-&gt;word = word;
        //for(char i = 'a'; i&lt;='z'; i++){
        //    auto c = kb[i];
        //    cout&lt;&lt;c.first&lt;&lt;&quot; &quot;&lt;&lt;c.second&lt;&lt;endl;
        //}
        coor f1{-1, -1};
        coor f2{-1, -1};
        return dp(0, f1, f2);
<A NAME="0"></A>    }
};

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match24-1.html#0',3,'match24-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>map&lt;char, coor&gt; Solution::kb = {
        {'A', {0,0}},
        {'B', {0,1}},
        {'C', {0,2}},
        {'D', {0,3}},
        {'E', {0,4}},
        {'F', {0,5}},
        {'G', {1,0}},
        {'H', {1,1}},
        {'I', {1,2}},
        {'J', {1,3}},
        {'K', {1,4}},
        {'L', {1,5}},
        {'M', {2,0}},
        {'N', {2,1}},
        {'O', {2,2}},
        {'P', {2,3}},
        {'Q', {2,4}},
        {'R', {2,5}},
        {'S', {3,0}},
        {'T', {3,1}},
        {'U', {3,2}},
        {'V', {3,3}},
        {'W', {3,4}},
        {'X', {3,5}},
        {'Y', {4,0}},
        {'Z', {4,1}},
    };</B></FONT>
</PRE>
</BODY>
</HTML>
