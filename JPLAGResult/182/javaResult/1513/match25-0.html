<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>87_nagabhushaniitr.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>87_nagabhushaniitr.java</CENTER></H3><HR>
<PRE>
<A NAME="0"></A>class Solution {
    private int[] bt;
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match25-1.html#0',3,'match25-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>private String a, b;
    private String evil;
    private int n;
    private long[][][][] dp;
    private final int MOD = (int)1e9+7;
    public int findGoodStrings(int n, String s1, String s2, String evil) {</B></FONT>
        bt = backTable(evil);
        a=s1;
        b=s2;
        this.evil = evil;
        this.n = n;
        dp = new long[n][2][2][51];
        for(int i=0; i&lt;n; i++) {
            for(int j=0; j&lt;2; j++) {
                for(int k=0; k&lt;2; k++) {
                    for(int z=0; z&lt;51; z++) {
<A NAME="1"></A>                        dp[i][j][k][z]=-1;
                    }
                }
            <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match25-1.html#1',3,'match25-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}
        }
        return (int)solve(0, 0, 0, 0);
    }
    
    private long solve(int i, int free1, int free2, int jj</B></FONT>) {
        if (jj==evil.length()) return 0;
        if (i==n) {
            return 1;
        }
        
        if (dp[i][free1][free2][jj]!=-1) return dp[i][free1][free2][jj];
        
        long ans = 0;
        
        if (free1==0 &amp;&amp; free2==0) {
            for(int k=0; k&lt;26; k++) {
                int j = jj;
                char c = (char)(k+'a');
                if (c&lt;a.charAt(i) || c&gt;b.charAt(i)) continue;
                int newFree1 = 0;
                int newFree2 = 0;
                if (c&gt;a.charAt(i)) newFree1 = 1;
                if (c&lt;b.charAt(i)) newFree2 = 1;
                if (evil.charAt(j)==c) {
                    ans = (ans+solve(i+1, newFree1, newFree2, j+1))%MOD;
                } else {
                    while(j!=0 &amp;&amp; c!=evil.charAt(j)) {
                        j=bt[j-1];
                    }
                    if (c==evil.charAt(j)) {
                        ans = (ans+solve(i+1, newFree1, newFree2, j+1))%MOD;
                    } else {
                        ans = (ans+solve(i+1, newFree1, newFree2, 0))%MOD;
                    }
                }
            }
        } else if (free1==0) {
             for(int k=0; k&lt;26; k++) {
                int j = jj;
                char c = (char)(k+'a');
                if (c&lt;a.charAt(i)) continue;
                int newFree1 = 0;
                int newFree2 = 1;
                if (c&gt;a.charAt(i)) newFree1 = 1;
                // if (c&lt;b.charAt(i)) newFree2 = 1;
                if (evil.charAt(j)==c) {
                    ans = (ans+solve(i+1, newFree1, newFree2, j+1))%MOD;
                } else {
                    while(j!=0 &amp;&amp; c!=evil.charAt(j)) {
                        j=bt[j-1];
                    }
                    if (c==evil.charAt(j)) {
                        ans = (ans+solve(i+1, newFree1, newFree2, j+1))%MOD;
                    } else {
                        ans = (ans+solve(i+1, newFree1, newFree2, 0))%MOD;
                    }
                }
            }
        } else if (free2==0) {
            for(int k=0; k&lt;26; k++) {
                int j = jj;
                char c = (char)(k+'a');
                if (c&gt;b.charAt(i)) continue;
                int newFree1 = 1;
                int newFree2 = 0;
                if (c&lt;b.charAt(i)) newFree2 = 1;
                // if (c&lt;b.charAt(i)) newFree2 = 1;
                if (evil.charAt(j)==c) {
                    ans = (ans+solve(i+1, newFree1, newFree2, j+1))%MOD;
                } else {
                    while(j!=0 &amp;&amp; c!=evil.charAt(j)) {
                        j=bt[j-1];
                    }
                    if (c==evil.charAt(j)) {
                        ans = (ans+solve(i+1, newFree1, newFree2, j+1))%MOD;
                    } else {
                        ans = (ans+solve(i+1, newFree1, newFree2, 0))%MOD;
                    }
                }
            }
        } else {
            for(int k=0; k&lt;26; k++) {
                int j = jj;
                char c = (char)(k+'a');
                if (evil.charAt(j)==c) {
                    ans = (ans+solve(i+1, 1, 1, j+1))%MOD;
                } else {
                    while(j!=0 &amp;&amp; c!=evil.charAt(j)) {
                        j=bt[j-1];
                    }
                    if (c==evil.charAt(j)) {
                        ans = (ans+solve(i+1, 1, 1, j+1))%MOD;
                    } else {
                        ans = (ans+solve(i+1, 1, 1, 0))%MOD;
                    }
                }
            }
        }
        
        // if (free==1) {
        //     for(int k=0; k&lt;26; k++) {
        //         int j = jj;
        //         char c = (char)(k+'a');
        //         if (evil.charAt(j)==c) {
        //             ans = (ans+solve(i+1, free, j+1));
        //         } else {
        //             while(j!=0 &amp;&amp; c!=evil.charAt(j)) {
        //                 j=bt[j-1];
        //             }
        //             if (c==evil.charAt(j)) {
        //                 ans = (ans+solve(i+1, free, j+1));
        //             } else {
        //                 ans = (ans+solve(i+1, free, 0));
        //             }
        //         }
        //     }
        // } else {
        //     for(int k=0; k&lt;26; k++) {
        //         int j = jj;
        //         char c = (char)(k+'a');
        //         if (c&lt;a.charAt(i) || c&gt;b.charAt(i)) continue;
        //         int newFree = (c!=a.charAt(i) &amp;&amp; c!=b.charAt(i)?1:0);
        //         if (evil.charAt(j)==c) {
        //             ans = (ans+solve(i+1, newFree, j+1));
        //         } else {
        //             while(j!=0 &amp;&amp; c!=evil.charAt(j)) {
        //                 j=bt[j-1];
        //             }
        //             if (c==evil.charAt(j)) {
        //                 ans = (ans+solve(i+1, newFree, j+1));
        //             } else {
        //                 ans = (ans+solve(i+1, newFree, 0));
        //             }
        //         }
        //     }
        // }
        return dp[i][free1][free2][jj]=ans;
        
    }
        
    private int[] backTable(String p) {
		int m = p.length();
		int[] b = new int[m]; // b[i] is the length of largest suffix ending 
							  // at i which is also a prefix
		
		int j=0;
		int i=1;
		
		while(i&lt;m) {
			if (p.charAt(i)==p.charAt(j)) {
				b[i] = j+1;
				i++;
				j++;
			} else {
				while(j!=0 &amp;&amp; p.charAt(i)!=p.charAt(j)){
					j = b[j-1];
				}
				if (p.charAt(j)==p.charAt(i)) {
					b[i]=j+1;
					j++;
				} 
				i++;
			}
		}
		
		return b;
	}
}
</PRE>

</BODY>
</HTML>
