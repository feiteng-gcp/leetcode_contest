<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>25_ianchew.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>25_ianchew.cpp</CENTER></H3><HR>
<PRE>
void do_stamp(string&amp; stamp, string&amp; target, int pos) {
    std::copy(stamp.begin(), stamp.end(), target.begin() + pos);
}

bool check_match(string&amp; stamp, string&amp; target, int pos) {
    int state = 0; // not in match yet
        for (int i=0; i&lt;stamp.size(); ++i) {
        int j = i+pos;
            if (stamp[i] != target[j]) {
                if (target[j] != '?') {
                    return false; //overlap, unstamping wrong parts.
                } else {
                    if (state == 1) {
                        state = 2;
                    }
                }
            } else {
                // Found a match
                if (state==0) {
                    state = 1;
                } else if (state == 2) {
                    // Found a second match, overlap.
                    return false;
                }
            }
        }
    return true;

}

// Get the length of the match at this position
int match_len(string&amp; stamp, string&amp; target, int pos) {
    int best = 0;
    int match_start = 0;
    for (int i=0; i&lt;stamp.size(); ++i) {
        int j = i+pos;
        if (stamp[i] == target[j]) {
            // Continue the current match
        } else {
            int len = i - match_start;
            if (len &gt; best) {
                best = len;
            }
            match_start = i+1;
        }
    }
    int len = stamp.size() - match_start;
    if (len &gt; best) {
        best = len;
    }
    return best;
}

<A NAME="0"></A>// Get the closest match position.
int best_match(string&amp; stamp, string&amp; target) {
    int best_len = 0;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match8-0.html#0',2,'match8-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    int best_pos = -1;
    for (int i=0; i&lt;=target.size() - stamp.size(); ++i) {
        int len = match_len(stamp, target, i);
        if (len &gt; best_len &amp;&amp; check_match(stamp, target, i)) {
            best_len = len;
            best_pos = i;</B></FONT>
        }
    }
//    cout &lt;&lt; best_len &lt;&lt; &quot; &quot;;
    return best_pos;
}

bool is_all_qmark(string&amp; s) {
    return s.find_first_not_of('?') != string::npos;
}



class Solution {
public:
    vector&lt;int&gt; movesToStamp(string stamp, string target) {
        // Stamping with this removes a stamp, so to speak.
        string unstamp(stamp.size(), '?');
        
        std::deque&lt;int&gt; moves;
        
        // While there are still non-? characters in the string
        while (target.find_first_not_of('?') != string::npos) {
            int pos = best_match(stamp, target);
            
//            cout &lt;&lt; target &lt;&lt; &quot; &quot; &lt;&lt; pos &lt;&lt; endl;
            if (!check_match(stamp, target, pos)) {
                // No match found.
                return {};
            }
            do_stamp(unstamp, target, pos);
            moves.push_front(pos);
        }
        return {moves.begin(), moves.end()};
    }
};
</PRE>
</BODY>
</HTML>
