<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>267_Kevin_Zhang_TW.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>267_Kevin_Zhang_TW.cpp</CENTER></H3><HR>
<PRE>
struct node{
	node* next[2] = {};
    int here = 0;
	// vector &lt; pair &lt; int, int &gt; &gt; indices;
};
struct trie{
	node* root = new node;
	void insert(const bitset &lt; 16 &gt; road, const int &amp;i, const int &amp;j, node* now, int indices = 0){
		if(indices == 16){
            ++now-&gt;here;
			// now-&gt;indices.push_back(make_pair(i, j));
			return;
		}
		if(!now-&gt;next[road[indices]])now-&gt;next[road[indices]] = new node;		
		insert(road, i, j, now-&gt;next[road[indices]], indices + 1);
	}
	int ok(const int &amp;k, const bitset &lt; 16 &gt; road, node* now, int indices = 0){
		if(!now)return 0;
        
		if(indices == 16){
            return now-&gt;here;
			// int sum = 0;
			// for(auto st : now-&gt;indices){
			// cout &lt;&lt; &quot;ok &quot;&lt;&lt;k &lt;&lt; ' ' &lt;&lt; st.first &lt;&lt; ' ' &lt;&lt; st.second &lt;&lt; '\n';
			// 	sum += k + st.first + st.second;
			// }
			// return sum;
		}
		if(road[indices]){
			return ok(k, road, now-&gt;next[0], indices + 1);
		}
<A NAME="0"></A>		return ok(k, road, now-&gt;next[0], indices + 1) + ok(k, road, now-&gt;next[1], indices + 1);
	}
};
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match32-1.html#0',3,'match32-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>class Solution {
public:
	//bitset &lt; 16 &gt;

    int countTriplets(vector&lt;int&gt;&amp; A) {
    	int size = A.size();
    	int answer = 0;
    	trie tree;
        for(int i = 0;i &lt; size;++i){
        	for(int j = 0;j &lt; size;++j){</B></FONT>
        		tree.insert(bitset &lt; 16 &gt; (A[i]&amp;A[j]), i, j, tree.root);
        	}
        }
        for(int k = 0;k &lt; size;++k){
        	answer += tree.ok(k, bitset &lt; 16 &gt; (A[k]), tree.root);
        }
        return answer;
    }
};
</PRE>
</BODY>
</HTML>
