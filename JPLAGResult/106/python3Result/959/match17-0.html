<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>423_45821A.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>423_45821A.py</CENTER></H3><HR>
<PRE>
from collections import Counter
class Solution:
    def threeSumMulti(self, A, target):
        &quot;&quot;&quot;
        :type A: List[int]
        :type target: int
        :rtype: int
        &quot;&quot;&quot;
        if len(A) == 3:
            return 1 if sum(A) == target else 0
        c = Counter(A)
        int_begin = {}
        uniques = list(sorted(c.keys()))
        result = self.ones(c, uniques, target) + self.twos(c, uniques, target) + self.threes(c, uniques, target)
        
        return result % (10**9 + 7)

    def ones(self, counter, uniques, target):
        if len(uniques) &lt; 3:
            return 0
        result = 0
        for i in range(len(uniques) - 2):
            if uniques[i] &gt; target:
                break
            for j in range(i + 1, len(uniques) - 1):
                if uniques[i] + uniques[j] &gt; target:
                    break
                if self.binary_search(uniques, target - uniques[i] - uniques[j], j + 1, len(uniques)):
                    result += counter[uniques[i]] * counter[uniques[j]] * counter[target - uniques[i] - uniques[j]]
        return result
    
    def twos(self, counter, uniques, target):
<A NAME="0"></A>        if len(uniques) &lt; 2:
            return 0
        result = 0
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match17-1.html#0',3,'match17-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>for i in range(len(uniques)):
            if uniques[i] &gt; target:
                break
            if counter[uniques[i]] &gt;= 2 and uniques[i] * 3 != target and self.</B></FONT>binary_search(uniques, target - uniques[i] * 2, 0, len(uniques)):
                count = counter[uniques[i]]
                result += count * (count - 1) // 2 * counter[target - uniques[i] * 2]
       # print(&quot;twos: {}&quot;.format(result))
        return result

    def threes(self, counter, uniques, target):
        for i in uniques:
            if i * 3 == target and counter[i] &gt;= 3:
                return counter[i] * (counter[i] - 1) * (counter[i] - 2) // 6
        return 0

    def binary_search(self, A, target, begin, end):
        while begin &lt; end:
            if begin == end - 1:
                return A[begin] == target
            mid = (begin + end) // 2
            if A[mid] == target:
                return True
            elif A[mid] &gt; target:
                end = mid
            else:
                begin = mid + 1
        return False
</PRE>

</BODY>
</HTML>
