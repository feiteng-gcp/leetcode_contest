<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>6_wjli.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>6_wjli.cpp</CENTER></H3><HR>
<PRE>

// Union-Find Disjoint Sets Library written in OOP manner, using both path compression and union by rank heuristics
// initialize: UnionFind UF(N)

class UnionFind {                                              // OOP style
private:
	vector&lt;int&gt; p, rank, setSize;
	// p = path toward the root of disjoint set; p[i] = i means it is root
	// rank = upper bound of the actual height of the tree; not reliable as accurate measure
	// setSize = size of each disjoint set

	int numSets;
public:
	UnionFind(int N) {
		setSize.assign(N, 1);
		numSets = N;
<A NAME="0"></A>		rank.assign(N, 0);
		p.assign(N, 0);
		for (int i = 0; i &lt; N; i++) p[i] = i;	// each belongs to its own set
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match25-1.html#0',3,'match25-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	}

	int findSet(int i) {
		return (p[i] == i) ? i : (p[i] = findSet(p[i]));		// path compression: cut short of the path if possible
	}

	bool isSameSet(int i, int j) {
		return findSet(i) == findSet(j);
	}

	void unionSet(int i, int j) {</B></FONT>
		if (!isSameSet(i, j)) {
			numSets--;
			int x = findSet(i), y = findSet(j);
			// rank is used to keep the tree short
			if (rank[x] &gt; rank[y]) { p[y] = x; setSize[x] += setSize[y]; }
			else {
				p[x] = y; setSize[y] += setSize[x];
				if (rank[x] == rank[y]) rank[y]++;
			}
		}
	}

	int numDisjointSets() {		// # of disjoint sets
		return numSets;
	}

	int sizeOfSet(int i) {		// size of set
		return setSize[findSet(i)];
	}
};


class Solution {
public:
	int regionsBySlashes(vector&lt;string&gt;&amp; grid) {
		int n = grid.size(), i, j, k, nn = n * n, t;

		UnionFind uf(n * n * 4);
		for (i = 0; i &lt; n; i++) {
			for (j = 0; j &lt; n; j++) {
				t = i * n + j;
				if (grid[i][j] == ' ') {
					uf.unionSet(t, nn + t);
					uf.unionSet(nn * 2 + t, nn + t);
					uf.unionSet(nn * 3 + t, nn + t);
				}
				else if (grid[i][j] == '/') {
<A NAME="1"></A>					uf.unionSet(t, nn + t);
					uf.unionSet(nn * 3 + t, nn * 2 + t);
				}
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match25-1.html#1',3,'match25-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>				else if (grid[i][j] == '\\') {
					uf.unionSet(t, nn * 3 + t);
					uf.unionSet(nn * 2 + t, nn + t);
				}

				if (j &lt; n - 1) {
					uf.unionSet(nn * 2 + t, t + 1);
				}

				if (i &lt; n - 1) {
					uf.unionSet(nn * 3 + t, nn + t + n);
				}
			}
		}

		int ans = uf.numDisjointSets();</B></FONT>
		return ans;
	}
};

</PRE>
</BODY>
</HTML>
