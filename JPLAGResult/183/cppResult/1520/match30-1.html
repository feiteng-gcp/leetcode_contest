<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>17_kotamanegi.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>17_kotamanegi.cpp</CENTER></H3><HR>
<PRE>
#define  _CRT_SECURE_NO_WARNINGS
#define _USE_MATH_DEFINES

#pragma comment (linker, &quot;/STACK:526000000&quot;)

#include &quot;bits/stdc++.h&quot;

using namespace std;
typedef string::const_iterator State;
#define eps 1e-5L
#define MAX_MOD 1000000007LL
#define GYAKU 500000004LL
#define MOD 998244353LL
#define pb push_back
#define mp make_pair
typedef long long ll;
#define REP(a,b) for(long long (a) = 0;(a) &lt; (b);++(a))
#define ALL(x) (x).begin(),(x).end()

// geometry library


typedef complex&lt;long double&gt; Point;
typedef pair&lt;complex&lt;long double&gt;, complex&lt;long double&gt;&gt; Line;

typedef struct Circle {
    complex&lt;long double&gt; center;
    long double r;
}Circle;

long double dot(Point a, Point b) {
    return (a.real() * b.real() + a.imag() * b.imag());
}
long double cross(Point a, Point b) {
    return (a.real() * b.imag() - a.imag() * b.real());
}

long double Dist_Line_Point(Line a, Point b) {
    if (dot(a.second - a.first, b - a.first) &lt; eps) return abs(b - a.first);
    if (dot(a.first - a.second, b - a.second) &lt; eps) return abs(b - a.second);
    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);
}

int is_intersected_ls(Line a, Line b) {
    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) &lt; eps) &amp;&amp;
        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) &lt; eps);
}

Point intersection_l(Line a, Line b) {
    Point da = a.second - a.first;
    Point db = b.second - b.first;
    return a.first + da * cross(db, b.first - a.first) / cross(db, da);
}

long double Dist_Line_Line(Line a, Line b) {
    if (is_intersected_ls(a, b) == 1) {
        return 0;
    }
    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });
}

pair&lt;Point, Point&gt; intersection_Circle_Circle(Circle a, Circle b) {
    long double dist = abs(a.center - b.center);
    assert(dist &lt;= eps + a.r + b.r);
    assert(dist + eps &gt;= abs(a.r - b.r));
    Point target = b.center - a.center;
    long double pointer = target.real() * target.real() + target.imag() * target.imag();
    long double aa = pointer + a.r * a.r - b.r * b.r;
    aa /= 2.0L;
    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,
            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };
    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,
        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };
    r = r + a.center;
    l = l + a.center;
    return mp(l, r);
}

//end of geometry

template&lt;typename A&gt;
A pows(A val, ll b) {
    assert(b &gt;= 1);
    A ans = val;
    b--;
    while (b) {
        if (b % 2) {
            ans *= val;
        }
        val *= val;
        b /= 2LL;
    }
    return ans;
}

template&lt;typename A&gt;
class Compressor {
public:
    bool is_zipped = false;
    map&lt;A, ll&gt; zipper;
    map&lt;ll, A&gt; unzipper;
    queue&lt;A&gt; fetcher;
    Compressor() {
        is_zipped = false;
        zipper.clear();
        unzipper.clear();
    }
    void add(A now) {
        assert(is_zipped == false);
        zipper[now] = 1;
        fetcher.push(now);
    }
    void exec() {
        assert(is_zipped == false);
        int cnt = 0;
        for (auto i = zipper.begin(); i != zipper.end(); ++i) {
            i-&gt;second = cnt;
            unzipper[cnt] = i-&gt;first;
            cnt++;
        }
        is_zipped = true;
    }
    ll fetch() {
        assert(is_zipped == true);
        A hoge = fetcher.front();
        fetcher.pop();
        return zipper[hoge];
    }
    ll zip(A now) {
        assert(is_zipped == true);
        assert(zipper.find(now) != zipper.end());
        return zipper[now];
    }
    A unzip(ll a) {
        assert(is_zipped == true);
        assert(a &lt; unzipper.size());
        return unzipper[a];
    }
    ll next(A now) {
        auto x = zipper.upper_bound(now);
        if (x == zipper.end()) return zipper.size();
        return (ll)((*x).second);
    }
    ll back(A now) {
        auto x = zipper.lower_bound(now);
        if (x == zipper.begin()) return -1;
        x--;
        return (ll)((*x).second);
    }
};

template&lt;typename A&gt;
class Matrix {
public:
    vector&lt;vector&lt;A&gt;&gt; data;
    Matrix(vector&lt;vector&lt;A&gt;&gt; a) :data(a) {

    }
    Matrix operator + (const Matrix obj) {
        vector&lt;vector&lt;A&gt;&gt; ans;
        assert(obj.data.size() == this-&gt;data.size());
        assert(obj.data[0].size() == this-&gt;data[0].size());
        REP(i, obj.data.size()) {
            ans.push_back(vector&lt;A&gt;());
            REP(q, obj.data[i].size()) {
                A hoge = obj.data[i][q] + (this-&gt;data[i][q]);
                ans.back().push_back(hoge);
            }
        }
        return Matrix(ans);
    }
    Matrix operator - (const Matrix obj) {
        vector&lt;vector&lt;A&gt;&gt; ans;
        assert(obj.data.size() == this-&gt;data.size());
        assert(obj.data[0].size() == this-&gt;data[0].size());
        REP(i, obj.data.size()) {
            ans.push_back(vector&lt;A&gt;());
            REP(q, obj.data[i].size()) {
                A hoge = this-&gt;data[i][q] - obj.data[i][q];
                ans.back().push_back(hoge);
            }
        }
        return Matrix(ans);
    }
    Matrix operator * (const Matrix obj) {
        vector&lt;vector&lt;A&gt;&gt; ans;
        assert(obj.data.size() == this-&gt;data[0].size());
        REP(i, this -&gt; data.size()) {
            ans.push_back(vector&lt;A&gt;());
            REP(q, obj.data[0].size()) {
                A hoge = (this-&gt;data[i][0]) * (obj.data[0][q]);
                for (int t = 1; t &lt; obj.data[i].size(); ++t) {
                    hoge += this-&gt;data[i][t] * obj.data[t][q];
                }
                ans.back().push_back(hoge);
            }
        }
        return Matrix(ans);
    }
    Matrix&amp; operator *= (const Matrix obj) {
        *this = (*this * obj);
        return *this;
    }
    Matrix&amp; operator += (const Matrix obj) {
        *this = (*this + obj);
        return *this;
    }
    Matrix&amp; operator -= (const Matrix obj) {
        *this = (*this - obj);
        return *this;
    }
};

template &lt;std::uint_fast64_t mod&gt;
class modint {
public:
    using u64 = std::uint_fast64_t;
    u64 value = 0;
    modint() :value(0LL){
    
    }
    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {

    }

    constexpr modint operator+(const modint rhs) const {
        return modint(*this) += rhs;
    }
    constexpr modint operator-(const modint rhs) const {
        return modint(*this) -= rhs;
    }
    constexpr modint operator*(const modint rhs) const {
        return modint(*this) *= rhs;
    }
    constexpr modint operator/(const modint rhs) const {
        return modint(*this) /= rhs;
    }
    constexpr modint&amp; operator+=(const modint rhs) {
        value += rhs.value;
        if (value &gt;= mod) {
            value -= mod;
        }
        return *this;
    }
    constexpr modint&amp; operator-=(const modint rhs) {
        if (value &lt; rhs.value) {
            value += mod;
        }
        value -= rhs.value;
        return *this;
    }
    constexpr modint&amp; operator*=(const modint rhs) {
        value = (value * rhs.value) % mod;
        return *this;
    }
    constexpr modint&amp; operator/=(modint rhs) {
        ll rem = mod - 2;
        while (rem) {
            if (rem % 2) {
                *this *= rhs;
            }
            rhs *= rhs;
            rem /= 2LL;
        }
        return *this;
    }
    bool operator &lt;(modint rhs) const {
        return value &lt; rhs.value;
    }
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, modint&amp; p) {
        os &lt;&lt; p.value;
        return (os);
    }
};

class Dice {
public:
    vector&lt;ll&gt; vertexs;
    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5
    Dice(vector&lt;ll&gt; init) :vertexs(init) {

    }
    //Look from Center
    void RtoL() {
        for (int q = 1; q &lt; 4; ++q) {
            swap(vertexs[q], vertexs[q + 1]);
        }
    }
    void LtoR() {
        for (int q = 3; q &gt;= 1; --q) {
            swap(vertexs[q], vertexs[q + 1]);
        }
    }
    void UtoD() {
        swap(vertexs[5], vertexs[4]);
        swap(vertexs[2], vertexs[5]);
        swap(vertexs[0], vertexs[2]);
    }
    void DtoU() {
        swap(vertexs[0], vertexs[2]);
        swap(vertexs[2], vertexs[5]);
        swap(vertexs[5], vertexs[4]);
    }
    bool ReachAble(Dice now) {
        set&lt;Dice&gt; hoge;
        queue&lt;Dice&gt; next;
        next.push(now);
        hoge.insert(now);
        while (next.empty() == false) {
            Dice seeing = next.front();
            next.pop();
            if (seeing == *this) return true;
            seeing.RtoL();
            if (hoge.count(seeing) == 0) {
                hoge.insert(seeing);
                next.push(seeing);
            }
            seeing.LtoR();
            seeing.LtoR();
            if (hoge.count(seeing) == 0) {
                hoge.insert(seeing);
                next.push(seeing);
            }
            seeing.RtoL();
            seeing.UtoD();
            if (hoge.count(seeing) == 0) {
                hoge.insert(seeing);
                next.push(seeing);
            }
            seeing.DtoU();
            seeing.DtoU();
            if (hoge.count(seeing) == 0) {
                hoge.insert(seeing);
                next.push(seeing);
            }
        }
        return false;
    }
    bool operator ==(const Dice&amp; a) {
        for (int q = 0; q &lt; 6; ++q) {
            if (a.vertexs[q] != (*this).vertexs[q]) {
                return false;
            }
        }
        return true;
    }
    bool operator &lt;(const Dice&amp; a) const {
        return (*this).vertexs &lt; a.vertexs;
    }
};

pair&lt;Dice, Dice&gt; TwoDimDice(int center, int up) {
    int target = 1;
    while (true) {
        if (center != target &amp;&amp; 7 - center != target &amp;&amp; up != target &amp;&amp; 7 - up != target) {
            break;
        }
        target++;
    }
    return mp(Dice(vector&lt;ll&gt;{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector&lt;ll&gt;{up, 7 - target, center, target, 7 - center, 7 - up}));
}

tuple&lt;Dice, Dice, Dice, Dice&gt; OneDimDice(int center) {
    int bo = min(center, 7 - center);
    pair&lt;int, int&gt; goa;
    if (bo == 1) {
        goa = mp(2, 3);
    }
    else if (bo == 2) {
        goa = mp(1, 3);
    }
    else if (bo == 3) {
        goa = mp(1, 2);
    }
    tuple&lt;Dice, Dice, Dice, Dice&gt; now = make_tuple(Dice(vector&lt;ll&gt;{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),
        Dice(vector&lt;ll&gt;{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),
        Dice(vector&lt;ll&gt;{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),
        Dice(vector&lt;ll&gt;{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));
    return now;
}

template&lt;typename A, typename B&gt;
class Dijkstra {
public:
    vector&lt;vector&lt;pair&lt;int, A&gt;&gt;&gt; vertexs;
    B Cost_Function;
    Dijkstra(int n, B cost) : Cost_Function(cost) {
        vertexs = vector&lt;vector&lt;pair&lt;int, A&gt;&gt;&gt;(n, vector&lt;pair&lt;int, A&gt;&gt;{});
    }
    ~Dijkstra() {
        vertexs.clear();
    }
    void add_edge(int a, int b, A c) {
        vertexs[a].push_back(mp(b, c));
    }
    vector&lt;ll&gt; build_result(int StartPoint) {
        vector&lt;ll&gt; dist(vertexs.size(), 2e18);
        dist[StartPoint] = 0;
        priority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt;&gt;, greater&lt;pair&lt;ll, int&gt;&gt;&gt; next;
        next.push(make_pair(0, StartPoint));
        while (next.empty() == false) {
            pair&lt;ll, int&gt; now = next.top();
            next.pop();
            if (dist[now.second] != now.first) continue;
            for (auto x : vertexs[now.second]) {
                ll now_cost = now.first + Cost_Function(x.second);
                if (dist[x.first] &gt; now_cost) {
                    dist[x.first] = now_cost;
                    next.push(mp(now_cost, x.first));
                }
            }
        }
        return dist;
    }
};

class Dinic {
public:
    struct edge {
        int to;
        int cap;
        int rev;
    };
    vector&lt;vector&lt;edge&gt;&gt; Graph;
    vector&lt;int&gt; level;
    vector&lt;int&gt; itr;
    Dinic(int n) {
        Graph = vector&lt;vector&lt;edge&gt;&gt;(n, vector&lt;edge&gt;());
    }
    void add_edge(int a, int b, int cap) {
        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });
        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });
    }
    void bfs(int s) {
        level = vector&lt;int&gt;(Graph.size(), -1);
        level[s] = 0;
        queue&lt;int&gt; next;
        next.push(s);
        while (next.empty() == false) {
            int now = next.front();
            next.pop();
            for (auto x : Graph[now]) {
                if (x.cap == 0) continue;
                if (level[x.to] == -1) {
                    level[x.to] = level[now] + 1;
                    next.push(x.to);
                }
            }
        }
    }
    int dfs(int now, int goal, int val) {
        if (goal == now) return val;
        for (int&amp; i = itr[now]; i &lt; (int)Graph[now].size(); ++i) {
            edge&amp; target = Graph[now][i];
            if (target.cap &gt; 0 &amp;&amp; level[now] &lt; level[target.to]) {
                int d = dfs(target.to, goal, min(val, target.cap));
                if (d &gt; 0) {
                    target.cap -= d;
                    Graph[target.to][target.rev].cap += d;
                    return d;
                }
            }
        }
        return 0;
    }
    int run(int s, int t) {
        int ans = 0;
        int f = 0;
        while (bfs(s), level[t] &gt;= 0) {
            itr = vector&lt;int&gt;(Graph.size(), 0);
            while ((f = dfs(s, t, 1e9)) &gt; 0) {
                ans += f;
            }
        }
        return ans;
    }
};


class HLDecomposition {
public:
    vector&lt;vector&lt;int&gt;&gt; vertexs;
    vector&lt;int&gt; depth;
    vector&lt;int&gt; backs;
    vector&lt;int&gt; connections;
    vector&lt;int&gt; zip, unzip;
    HLDecomposition(int n) {
        vertexs = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;());
        depth = vector&lt;int&gt;(n);
        zip = vector&lt;int&gt;(n);
        unzip = zip;
    }
    void add_edge(int a, int b) {
        vertexs[a].push_back(b);
        vertexs[b].push_back(a);
    }
    int depth_dfs(int now, int back) {
        depth[now] = 0;
        for (auto x : vertexs[now]) {
            if (x == back) continue;
            depth[now] = max(depth[now], 1 + depth_dfs(x, now));
        }
        return depth[now];
    }
    void dfs(int now, int backing) {
        zip[now] = backs.size();
        unzip[backs.size()] = now;
        backs.push_back(backing);
        int now_max = -1;
        int itr = -1;
        for (auto x : vertexs[now]) {
            if (depth[x] &gt; depth[now]) continue;
            if (now_max &lt; depth[x]) {
                now_max = depth[x];
                itr = x;
            }
        }
        if (itr == -1) return;
        connections.push_back(connections.back());
        dfs(itr, backing);
        for (auto x : vertexs[now]) {
            if (depth[x] &gt; depth[now]) continue;
            if (x == itr) continue;
            connections.push_back(zip[now]);
            dfs(x, backs.size());
        }
        return;
    }
    void build() {
        depth_dfs(0, -1);
        connections.push_back(-1);
        dfs(0, -1);
    }
    vector&lt;pair&lt;int, int&gt;&gt; query(int a, int b) {
        a = zip[a];
        b = zip[b];
        vector&lt;pair&lt;int, int&gt;&gt; ans;
        while (backs[a] != backs[b]) {
            if (a &lt; b) swap(a, b);
            ans.push_back(mp(backs[a], a + 1));
            a = connections[a];
        }
        if (a &gt; b) swap(a, b);
        ans.push_back(mp(a, b + 1));
        return ans;
    }
    int lca(int a, int b) {
        a = zip[a];
        b = zip[b];
        while (backs[a] != backs[b]) {
            if (a &lt; b) swap(a, b);
            a = connections[a];
        }
        return unzip[min(a, b)];
    }
};
//by ei1333
//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html
template&lt; typename Monoid &gt;
struct SegmentTree {
    using F = function&lt; Monoid(Monoid, Monoid) &gt;;

    int sz;
    vector&lt; Monoid &gt; seg;

    const F f;
    const Monoid M1;

    SegmentTree(int n, const F f, const Monoid&amp; M1) : f(f), M1(M1) {
        sz = 1;
        while (sz &lt; n) sz &lt;&lt;= 1;
        seg.assign(2 * sz + 1, M1);
    }

    void set(int k, const Monoid&amp; x) {
        seg[k + sz] = x;
    }

    void build() {
        for (int k = sz - 1; k &gt; 0; k--) {
            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);
        }
    }

    void update(int k, const Monoid&amp; x) {
        k += sz;
        seg[k] = x;
        while (k &gt;&gt;= 1) {
            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);
        }
    }

    Monoid query(int a, int b) {
        Monoid L = M1, R = M1;
        for (a += sz, b += sz; a &lt; b; a &gt;&gt;= 1, b &gt;&gt;= 1) {
            if (a &amp; 1) L = f(L, seg[a++]);
            if (b &amp; 1) R = f(seg[--b], R);
        }
        return f(L, R);
    }

    Monoid operator[](const int&amp; k) const {
        return seg[k + sz];
    }

    template&lt; typename C &gt;
    int find_subtree(int a, const C&amp; check, Monoid&amp; M, bool type) {
        while (a &lt; sz) {
            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);
            if (check(nxt)) a = 2 * a + type;
            else M = nxt, a = 2 * a + 1 - type;
        }
        return a - sz;
    }


    template&lt; typename C &gt;
    int find_first(int a, const C&amp; check) {
        Monoid L = M1;
        if (a &lt;= 0) {
            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);
            return -1;
        }
        int b = sz;
        for (a += sz, b += sz; a &lt; b; a &gt;&gt;= 1, b &gt;&gt;= 1) {
            if (a &amp; 1) {
                Monoid nxt = f(L, seg[a]);
                if (check(nxt)) return find_subtree(a, check, L, false);
                L = nxt;
                ++a;
            }
        }
        return -1;
    }

    template&lt; typename C &gt;
    int find_last(int b, const C&amp; check) {
        Monoid R = M1;
        if (b &gt;= sz) {
            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);
            return -1;
        }
        int a = sz;
        for (b += sz; a &lt; b; a &gt;&gt;= 1, b &gt;&gt;= 1) {
            if (b &amp; 1) {
                Monoid nxt = f(seg[--b], R);
                if (check(nxt)) return find_subtree(b, check, R, true);
                R = nxt;
            }
        }
        return -1;
    }
};

template&lt; typename Monoid, typename OperatorMonoid = Monoid &gt;
struct LazySegmentTree {
    using F = function&lt; Monoid(Monoid, Monoid) &gt;;
    using G = function&lt; Monoid(Monoid, OperatorMonoid, int) &gt;;
    using H = function&lt; OperatorMonoid(OperatorMonoid, OperatorMonoid) &gt;;

    int sz, height;
    vector&lt; Monoid &gt; data;
    vector&lt; OperatorMonoid &gt; lazy;
    const F f;
    const G g;
    const H h;
    const Monoid M1;
    const OperatorMonoid OM0;


    LazySegmentTree(int n, const F f, const G g, const H h,
        const Monoid&amp; M1, const OperatorMonoid OM0)
        : f(f), g(g), h(h), M1(M1), OM0(OM0) {
        sz = 1;
        height = 0;
        while (sz &lt; n) sz &lt;&lt;= 1, height++;
        data.assign(2 * sz, M1);
        lazy.assign(2 * sz, OM0);
    }

    void set(int k, const Monoid&amp; x) {
        data[k + sz] = x;
    }

    void build() {
        for (int k = sz - 1; k &gt; 0; k--) {
            data[k] = f(data[2 * k + 0], data[2 * k + 1]);
        }
    }

    inline void propagate(int k) {
        if (lazy[k] != OM0) {
            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);
            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);
            data[k] = reflect(k);
            lazy[k] = OM0;
        }
    }

    inline Monoid reflect(int k) {
        if (lazy[k] == OM0) return data[k];
        for (int q = sz; q &gt;= 0; q /= 2) {
            if (q &amp; k) {
                return g(data[k], lazy[k], sz / q);
            }
        }
    }

    inline void recalc(int k) {
        while (k &gt;&gt;= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));
    }

    inline void thrust(int k) {
for (int i = height; i &gt; 0; i--) propagate(k &gt;&gt; i);
    }

    void update(int a, int b, const OperatorMonoid&amp; x) {
        thrust(a += sz);
        thrust(b += sz - 1);
        for (int l = a, r = b + 1; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
            if (l &amp; 1) lazy[l] = h(lazy[l], x), ++l;
            if (r &amp; 1) --r, lazy[r] = h(lazy[r], x);
        }
        recalc(a);
        recalc(b);
    }

    Monoid query(int a, int b) {
        thrust(a += sz);
        thrust(b += sz - 1);
        Monoid L = M1, R = M1;
        for (int l = a, r = b + 1; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
            if (l &amp; 1) L = f(L, reflect(l++));
            if (r &amp; 1) R = f(reflect(--r), R);
        }
        return f(L, R);
    }

    Monoid operator[](const int&amp; k) {
        return query(k, k + 1);
    }

    template&lt; typename C &gt;
    int find_subtree(int a, const C&amp; check, Monoid&amp; M, bool type) {
        while (a &lt; sz) {
            propagate(a);
            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));
            if (check(nxt)) a = 2 * a + type;
            else M = nxt, a = 2 * a + 1 - type;
        }
        return a - sz;
    }

    template&lt; typename C &gt;
    int find_first(int a, const C&amp; check) {
        Monoid L = M1;
        if (a &lt;= 0) {
            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);
            return -1;
        }
        thrust(a + sz);
        int b = sz;
        for (a += sz, b += sz; a &lt; b; a &gt;&gt;= 1, b &gt;&gt;= 1) {
            if (a &amp; 1) {
                Monoid nxt = f(L, reflect(a));
                if (check(nxt)) return find_subtree(a, check, L, false);
                L = nxt;
                ++a;
            }
        }
        return -1;
    }


    template&lt; typename C &gt;
    int find_last(int b, const C&amp; check) {
        Monoid R = M1;
        if (b &gt;= sz) {
            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);
            return -1;
        }
        thrust(b + sz - 1);
        int a = sz;
        for (b += sz; a &lt; b; a &gt;&gt;= 1, b &gt;&gt;= 1) {
            if (b &amp; 1) {
                Monoid nxt = f(reflect(--b), R);
                if (check(nxt)) return find_subtree(b, check, R, true);
                R = nxt;
            }
        }
        return -1;
    }
};



unsigned long xor128() {
    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;
    unsigned long t = (x ^ (x &lt;&lt; 11));
    x = y; y = z; z = w;
<A NAME="0"></A>    return (w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8)));
}

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match30-0.html#0',2,'match30-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>class Solution {
public:
    int numSteps(string s) {
        int ans = 0;
<A NAME="1"></A>        while (s != &quot;1&quot;) {
            ans++;
            if (s.back() == '1') {</B></FONT>
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match30-0.html#1',2,'match30-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>                int ok = 1;
                for (int q = s.size()-1; q &gt;= 0; --q) {
                    if (s[q] == '1') {
                        s[q] = '0';
                    }
                    else {
                        ok = 0;
                        s[q] = '1';
                        break;
                    }
                }
                if (ok == 1) {</B></FONT>
                    s.insert(s.begin(), '1');
                }
            }
            else {
                s.pop_back();
            }
        }
        return ans;
    }
};
</PRE>
</BODY>
</HTML>
