<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>329_tocque.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>329_tocque.cpp</CENTER></H3><HR>
<PRE>
<A NAME="0"></A>class Solution {
public:
    const static int N = 1e5+5;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1-1.html#0',3,'match1-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    int sa[N], rk[N], ht[N], s[N&lt;&lt;1], t[N&lt;&lt;1], p[N], cnt[N], cur[N];
    #define pushS(x) sa[cur[s[x]]--] = x
    #define pushL(x) sa[cur[s[x]]++] = x
    #define inducedSort(v) fill_n(sa, n, -1); fill_n(cnt, m, 0);                  \
        for (int i = 0; i &lt; n; i++) cnt[s[i]]++;                                  \
        for (int i = 1; i &lt; m; i++) cnt[i] += cnt[i-1];                           \
        for (int i = 0; i &lt; m; i++) cur[i] = cnt[i]-1;                            \
        for (int i = n1-1; ~i; i--) pushS(v[i]);                                  \
        for (int i = 1; i &lt; m; i++) cur[i] = cnt[i-1];                            \
        for (int i = 0; i &lt; n; i++) if (sa[i] &gt; 0 &amp;&amp;  t[sa[i]-1]) pushL(sa[i]-1); \
        for (int i = 0; i &lt; m; i++) cur[i] = cnt[i]-1;                            \
        for (int i = n-1;  ~i; i--) if (sa[i] &gt; 0 &amp;&amp; !t[sa[i]-1]) pushS(sa[i]-1)
    void sais(int n, int m, int *s, int *t, int *p) {
        int n1 = t[n-1] = 0, ch = rk[0] = -1, *s1 = s+n;
        for (int i = n-2; ~i; i--) t[i] = s[i] == s[i+1] ? t[i+1] : s[i] &gt; s[i+1];
        for (int i = 1; i &lt; n; i++) rk[i] = t[i-1] &amp;&amp; !t[i] ? (p[n1] = i, n1++) : -1;
        inducedSort(p);
        for (int i = 0, x, y; i &lt; n; i++) if (~(x = rk[sa[i]])) {
            if (ch &lt; 1 || p[x+1] - p[x] != p[y+1] - p[y]) ch++;
            else for (int j = p[x], k = p[y]; j &lt;= p[x+1]; j++, k++)
                if ((s[j]&lt;&lt;1|t[j]) != (s[k]&lt;&lt;1|t[k])) {ch++; break;}
            s1[y = x] = ch;
        }
        if (ch+1 &lt; n1) sais(n1, ch+1, s1, t+n, p+n1);
        else for (int i = 0; i &lt; n1; i++) sa[s1[i]] = i;
        for (int i = 0; i &lt; n1; i++) s1[i] = p[sa[i]];
        inducedSort(s1);
    }
    template&lt;typename T&gt;
    int mapCharToInt(int n, const T *str) {
        int m = *max_element(str, str+n);
        fill_n(rk, m+1, 0);
        for (int i = 0; i &lt; n; i++) rk[str[i]] = 1;
        for (int i = 0; i &lt; m; i++) rk[i+1] += rk[i];
        for (int i = 0; i &lt; n; i++) s[i] = rk[str[i]] - 1;
        return rk[m];
    }
    // Ensure that str[n] is the unique lexicographically smallest character in str.
    template&lt;typename T&gt;
    void suffixArray(int n, const T *str) {
        int m = mapCharToInt(++n, str);
        sais(n, m, s, t, p);
        for (int i = 0; i &lt; n; i++) rk[sa[i]] = i;
        for (int i = 0, h = ht[0] = 0; i &lt; n-1; i++) {
            int j = sa[rk[i]-1];
            while (i+h &lt; n &amp;&amp; j+h &lt; n &amp;&amp; s[i+h] == s[j+h]) h++;
            if (ht[rk[i]] = h) h--;
        }
    }</B></FONT>
    string lastSubstring(string s) {
        int n = s.size();
        s.push_back(0);
        suffixArray(n, s.c_str());
        return string(s.begin()+sa[n], s.end()-1);
    }
};
</PRE>
</BODY>
</HTML>
