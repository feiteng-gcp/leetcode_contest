<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>72_wechat_cph.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>72_wechat_cph.cpp</CENTER></H3><HR>
<PRE>
class Solution {
public:
    bool isEscapePossible(vector&lt;vector&lt;int&gt;&gt;&amp; blocked, vector&lt;int&gt;&amp; source, vector&lt;int&gt;&amp; target) {
		int bn = blocked.size();
		if(bn == 0) return true;
		pair&lt;int, int&gt; st = make_pair(source[0], source[1]);
		pair&lt;int, int&gt; ed = make_pair(target[0], target[1]);
		int N = 1000000;
		auto encode = [&amp;](pair&lt;int, int&gt; p) -&gt; long long {
			return (long long)p.first*N + p.second;
		};
		auto decode = [&amp;](long long v) -&gt; pair&lt;int, int&gt; {
			return make_pair(v/N, v%N);
		};
		unordered_set&lt;long long &gt; bbs;
		for(auto &amp;b:blocked) {
			bbs.insert(encode(make_pair(b[0], b[1])));
		}

		{
			unordered_map&lt;long long, int&gt; visit;
<A NAME="0"></A>			queue&lt;pair&lt;int, int&gt; &gt; qe;
			qe.push(st);
			visit[encode(st)] = 0;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match32-1.html#0',3,'match32-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			int d[][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};</B></FONT>
			int walk = 0;
			while(!qe.empty()) {
				auto p = qe.front();
				auto ep = encode(p);
				walk = visit[ep];
				if(walk&gt;=200) break;
				qe.pop();
				for(int i = 0; i&lt;4; i++) {
					int x = p.first+d[i][0], y = p.second+d[i][1];
					if(x&lt;0 || x&gt;=N || y&lt;0 || y&gt;=N) continue;
					auto q = make_pair(x, y);
					auto ex = encode(q);
					if(visit.find(ex) != visit.end()) continue;
					if(bbs.find(ex) != bbs.end()) continue;
					if(q == ed) return true;
					qe.push(q);
					visit[ex] = visit[ep] + 1;
				}
			}
			if(walk&lt;200) return false;
		}


		{
			unordered_map&lt;long long, int&gt; visit;
			queue&lt;pair&lt;int, int&gt; &gt; qe;
			qe.push(ed);
			visit[encode(ed)] = 0;
			int d[][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
			int walk = 0;
			while(!qe.empty()) {
				auto p = qe.front();
				auto ep = encode(p);
				walk = visit[ep];
				if(walk&gt;=200) break;
				qe.pop();
				for(int i = 0; i&lt;4; i++) {
					int x = p.first+d[i][0], y = p.second+d[i][1];
					if(x&lt;0 || x&gt;=N || y&lt;0 || y&gt;=N) continue;
					auto q = make_pair(x, y);
					auto ex = encode(q);
					if(visit.find(ex) != visit.end()) continue;
					if(bbs.find(ex) != bbs.end()) continue;
					if(q == st) return true;
					qe.push(q);
					visit[ex] = visit[ep] + 1;
				}
			}
			if(walk&lt;200) return false;
		}
		return true;
    }
};
</PRE>
</BODY>
</HTML>
