<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>128_yyfish88.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>128_yyfish88.cpp</CENTER></H3><HR>
<PRE>
class Solution {
public:
    struct pair_hash {
    inline std::size_t operator()(const std::pair&lt;int,int&gt; &amp; v) const {
        return v.first*31+v.second;
    }
    };
    
    bool isEscapePossible(vector&lt;vector&lt;int&gt;&gt;&amp; blocked, vector&lt;int&gt;&amp; source, vector&lt;int&gt;&amp; target) {
        pair&lt;int, int&gt; s{source[0], source[1]};
        pair&lt;int, int&gt; t{target[0], target[1]};
        unordered_set&lt;pair&lt;int, int&gt;, pair_hash&gt; blocks;
        for(auto &amp;vi: blocked){
            blocks.insert(make_pair(vi[0], vi[1]));
        }
        unordered_set&lt;pair&lt;int, int&gt;, pair_hash&gt; visited;
        int count = 12000;
<A NAME="0"></A>        queue&lt;pair&lt;int, int&gt;&gt; q;
        q.push(s);
        visited.insert(s);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match31-0.html#0',2,'match31-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        static int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, -1}};</B></FONT>
        bool s_free = false, t_free=false;
        while(!q.empty()&amp;&amp;count&gt;0){
            //auto &amp;p = q.front();
            auto p = q.front();
            //cout&lt;&lt;&quot;s:&quot;&lt;&lt;p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second&lt;&lt;endl;
            //cout&lt;&lt;q.size()&lt;&lt;endl;
            q.pop();
            for(int i = 0; i&lt;4; i++){
                auto nei = make_pair(p.first+offsets[i][0], p.second+offsets[i][1]);
                //cout&lt;&lt;&quot;nei:&quot;&lt;&lt;nei.first&lt;&lt;&quot; &quot;&lt;&lt;nei.second&lt;&lt;endl;
                if(nei.first&lt;0||nei.first&gt;=1000000||nei.second&lt;0||nei.second&gt;=1000000)continue;
                if(visited.count(nei))continue;
                if(blocks.count(nei))continue;
                if(nei==t)return true;
                visited.insert(nei);
                q.push(nei);
            }
            //cout&lt;&lt;q.size()&lt;&lt;endl;
            count--;
        }
        if(count==0)s_free=true;
        //cout&lt;&lt;&quot;here&quot;;
        q=queue&lt;pair&lt;int, int&gt;&gt;();
        q.push(t);
        visited.insert(t);
        count=12000;
        
        while(!q.empty()&amp;&amp;count&gt;0){
            //auto &amp;p = q.front();
            auto p = q.front();
            //cout&lt;&lt;&quot;t:&quot;&lt;&lt;p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second&lt;&lt;endl;
            //cout&lt;&lt;q.size()&lt;&lt;endl;
            q.pop();
            for(int i = 0; i&lt;4; i++){
                auto nei = make_pair(p.first+offsets[i][0], p.second+offsets[i][1]);
                if(nei.first&lt;0||nei.first&gt;=1000000||nei.second&lt;0||nei.second&gt;=1000000)continue;
                if(visited.count(nei))continue;
                if(blocks.count(nei))continue;
                if(nei==s)return true;
                visited.insert(nei);
                q.push(nei);
            }
            count--;
        }
       
        if(count==0)t_free=true;
        return s_free&amp;&amp;t_free;
    }
};
</PRE>
</BODY>
</HTML>
