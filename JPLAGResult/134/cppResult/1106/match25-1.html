<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>137_FoolPerson.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>137_FoolPerson.cpp</CENTER></H3><HR>
<PRE>
class Solution {
public:
    const int N = 1000000;
    struct Point {
        int x, y;
        Point(int x = 0, int y = 0): x(x), y(y) {}
        bool operator &lt;(const Point &amp;B) const {return x &lt; B.x || (x == B.x &amp;&amp; y &lt; B.y);}
    };
    set&lt;Point&gt; blocks;
    bool isEscapePossible(vector&lt;vector&lt;int&gt;&gt;&amp; blocked, vector&lt;int&gt;&amp; source, vector&lt;int&gt;&amp; target) {
        for (auto p: blocked) {
            if (dist(p[0], p[1], source[0], source[1]) &lt;= 200 || dist(p[0], p[1], target[0], target[1]) &lt;= 200)
                blocks.insert(Point(p[0], p[1]));
        }
        int ret = BFS(source[0], source[1], target[0], target[1]);
        if (ret == 2) // Can reach target
            return true;
        if (ret == 0) // Blocked
            return false;
        // Otherwise, ret == 1.
        if (BFS(target[0], target[1], source[0], source[1]) == 1)
            return true;
        return false;
    }
<A NAME="0"></A>    int BFS(int x1, int y1, int x2, int y2) {
        queue&lt;Point&gt; Q;
        // map&lt;Point, int&gt; d;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match25-0.html#0',2,'match25-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        vector&lt;vector&lt;int&gt;&gt; d(405, vector&lt;int&gt;(405, -1));
        Q.push(Point(x1, y1));
        // d[Point(x1, y1)] = 0;
        d[0][0] = 0;
        const int dx[] = {-1, 0, 1, 0};
        const int dy[] = {0, -1, 0, 1};
        while (!Q.empty()) {</B></FONT>
            Point p = Q.front();
            if (d[p.x - x1 + 202][p.y - y1 + 202] &gt;= 200) break;
            Q.pop();
            int x = p.x, y = p.y;
            Point p2;
            for (int i = 0; i &lt; 4; ++i) {
                p2.x = x + dx[i], p2.y = y + dy[i];
                if (ok(p2.x, p2.y) &amp;&amp; !blocks.count(p2) &amp;&amp; d[p2.x - x1 + 202][p2.y - y1 + 202] &lt; 0) {
                    if (p2.x == x2 &amp;&amp; p2.y == y2) return 2; // Reached
                    Q.push(p2);
                    d[p2.x - x1 + 202][p2.y - y1 + 202] = d[p.x - x1 + 202][p.y - y1 + 202] + 1;
                }
            }
        }
        return !Q.empty();
    }
    bool ok(int x, int y) {
        return x &gt;= 0 &amp;&amp; x &lt; N &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; N;
    }
    int dist(int x, int y, int z, int w) {
        return abs(x - z) + abs(y - w);
    }
};
</PRE>
</BODY>
</HTML>
