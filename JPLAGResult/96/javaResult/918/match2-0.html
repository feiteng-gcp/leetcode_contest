<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>24_nevergiveup.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>24_nevergiveup.java</CENTER></H3><HR>
<PRE>
class Solution {

	private static class Element implements Comparable&lt;Element&gt; {
		public int index;
		public int dist;
		public Element(int index , int dist) {
			this.index = index;
			this.dist = dist;
		}
		@Override
		public int compareTo(Element e) {
			if (this.dist &lt; e.dist) {
				return - 1;
			} else if (this.dist &gt; e.dist) {
				return 1;
			} else {
				return 0;
			}
		}
	}
	
	private static class Edge {
		public int to;
		public int dist;
		public int value;
		public Edge(int to , int dist) {
			this.to = to;
			this.dist = dist;
			this.value = 0;
		}
	}
	
	private static class Pair {
		public int from , to;
		public Pair(int from , int to) {
			this.from = from;
			this.to = to;
		}
		@Override
		public int hashCode() {
			int ans = 31;
			ans = ans * 37 + from;
			ans = ans * 37 + to;
			return ans;
		}
		@Override
		public boolean equals(Object object) {
			Pair value = (Pair) object;
			return this.from == value.from &amp;&amp; 
					this.to == value.to;
		}
	}

	private static List&lt;Edge&gt;[] graph = new ArrayList[30010];
	
	static {
		for (int i = 0;i &lt; 30010;i ++) {
			graph[i] = new ArrayList&lt;&gt;();
		}
	}
	

	private int[] dist;
	
    public int reachableNodes(int[][] edges, int M, int N) {
    	for (int i = 0;i &lt; N;i ++) {
    		graph[i].clear();
    	}
    	dist = new int[N];
    	for (int[] edge : edges) {
    		int from = edge[0] , to = edge[1] , value = edge[2];
    		graph[from].add(new Edge(to , value));
    		graph[to].add(new Edge(from , value));
    	}
    	
    	PriorityQueue&lt;Element&gt; queue = new PriorityQueue&lt;&gt;();
    	Arrays.fill(dist , - 1);
    	dist[0] = 0;
    	queue.add(new Element(0 , 0));
    	
    	while (!queue.isEmpty()) {
    		Element e = queue.poll();
    		if (e.dist == dist[e.index]) {
    			for (Edge edge : graph[e.index]) {
    				int nextDist = e.dist + edge.dist + 1;
    				if (nextDist &lt;= M) {
    					edge.value = edge.dist;
    					if (nextDist &lt; dist[edge.to] || dist[edge.to] &lt; 0) {
    						dist[edge.to] = nextDist;
    						queue.add(new Element(edge.to , nextDist));
    					}
    				} else {
    					int temp = M - e.dist;
    					if (temp &gt; edge.value) {
    						edge.value = temp;
    					}
    				}
    			}
    		}
<A NAME="0"></A>    	}
    	// all big point
    	int ans = 0;
    	for<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match2-1.html#0',3,'match2-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B> (int i = 0;i &lt; N;i ++) {
    		if (dist[i] &gt;= 0) {
    			ans ++;
    		}
    	}</B></FONT>
    	
    	Map&lt;Pair , Integer&gt; map = new HashMap&lt;&gt;();
    	for (int i = 0;i &lt; N;i ++) {
    		for (Edge edge : graph[i]) {
    			int from = i , to = edge.to;
    			map.put(new Pair(from , to) , edge.value);
    		}
    	}
    	
    	for (int[] edge : edges) {
    		int from = edge[0] , to = edge[1];
    		Pair pair1 = new Pair(from , to);
    		Pair pair2 = new Pair(to , from);
    		if (map.containsKey(pair1)) {
    			int value1 = map.get(pair1) , value2 = map.get(pair2);
    			if (value1 + value2 &lt;= edge[2]) {
    				ans += (value1 + value2);
    			} else {
    				ans += edge[2];
    			}
    		}
    	}
    	return ans;
    	
    }
	
}
</PRE>

</BODY>
</HTML>
