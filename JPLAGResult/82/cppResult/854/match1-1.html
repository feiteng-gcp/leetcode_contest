<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>5_szfck.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>5_szfck.cpp</CENTER></H3><HR>
<PRE>
class Solution {
public:
    int c[3000];
    int f[3000];
    int n, m;
    int find(int x) {
<A NAME="0"></A>        if (x == f[x]) return x;
        return f[x] = find(f[x]);
    }
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1-0.html#0',2,'match1-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    int dir[8] = {0, 1, 0, -1, 1, 0, -1, 0};
    void uni(int x, int y) {
        x = find(x);
        y = find(y);
        if (x != y) {
            f[x] = y;
            c[y] += c[x];
        }
    }</B></FONT>
    int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        n = grid.size();
        m = grid[0].size();
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; m; j++) {
                int id = i * m + j;
                f[id] = id;
                c[id] = grid[i][j];
            }
        }
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; m; j++) {
                if (grid[i][j] == 0) continue;
                for (int k = 0; k &lt; 8; ) {
                    int dx = i + dir[k++];
                    int dy = j + dir[k++];
                    if (dx &lt; 0 || dx &gt;= n || dy &lt; 0 || dy &gt;= m || grid[dx][dy] == 0) continue;
                    uni(i * m + j, dx * m + dy);
                }
            }
        }
        int res = 0;
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; m; j++) {
                if (grid[i][j] == 1) {
                    res = max(res, c[find(i * m + j)]);
                } else {
                    int tmp = 1;
                    vector&lt;int&gt; nxt;
                    for (int k = 0; k &lt; 8; ) {
                        int dx = i + dir[k++];
                        int dy = j + dir[k++];
                        if (dx &lt; 0 || dx &gt;= n || dy &lt; 0 || dy &gt;= m || grid[dx][dy] == 0) continue;
                        int id = find(dx * m + dy);
                        bool ok = true;
                        for (auto v : nxt) {
                            if (id == v) {
                                ok = false;
                                break;
                            }
                        }
                        if (ok) {
                            tmp += c[id];
                            nxt.push_back(id);
                        }
                    }
                    res = max(res, tmp);
                }
            }
        }
        return res;
    }
};
</PRE>
</BODY>
</HTML>
