<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>70_lh0829.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>70_lh0829.cpp</CENTER></H3><HR>
<PRE>
class Solution {
public:
    int maxSubarraySumCircular(vector&lt;int&gt;&amp; A) {
        int mv=*max_element(begin(A),end(A));
        int rst=KadaneCircular(A,A.size());
        if(rst&gt;mv &amp;&amp; mv&lt;0) rst=mv;
        return rst;
    }
    int kadane(vector&lt;int&gt;&amp; arr, int n)
{
    // stores maximum sum sub-array found so far
<A NAME="0"></A>    int max_so_far = 0;

    // stores maximum sum of sub-array ending at current position
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match11-1.html#0',3,'match11-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    int max_ending_here = 0;

    // traverse the given array
    for (int i = 0; i &lt; n; i++)
    {
        // update maximum sum of sub-array &quot;ending&quot; at index i (by adding
        // current element to maximum sum ending at previous index i-1)
        max_ending_here = max_ending_here + arr[i];

        // if maximum sum is negative, set it to 0 (which represents
        // an empty sub-array)
        max_ending_here = max(max_ending_here, 0);

        // update result if current sub-array sum is found to be greater
        max_so_far = max(max_so_far, max_ending_here);
    }

    return max_so_far;
}

// Function to find maximum sum circular subarray in a given array
<A NAME="1"></A>int KadaneCircular(vector&lt;int&gt;&amp; arr, int n)</B></FONT>
{
    // negate all elements of the array
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match11-1.html#1',3,'match11-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    for (int i = 0; i &lt; n; i++)
        arr[i] = -arr[i];

    // run Kadane's algorithm on modified array
    int negMaxSum = kadane(arr, n);

    // restore the array
    for (int i = 0; i &lt; n; i++)
        arr[i] = -arr[i];

    /*  return maximum of

        1. sum returned by Kadane's algorithm on original array.

        2. sum returned by Kadane's algorithm on modified array +
           sum of all elements of the array.
    */

    return max(kadane(arr, n), accumulate(begin(arr), end(arr), 0) + negMaxSum);
}
};</B></FONT>
</PRE>
</BODY>
</HTML>
