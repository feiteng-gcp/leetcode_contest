<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>275_lyongu.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>275_lyongu.py</CENTER></H3><HR>
<PRE>
class Solution:
    def minMalwareSpread(self, graph, initial):
        &quot;&quot;&quot;
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        &quot;&quot;&quot;
        n = len(graph)
        uf = {}
        
<A NAME="0"></A>        def find(i):
            if i not in uf:
                uf[i] = -1
            <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match4-0.html#0',2,'match4-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if uf[i] &lt; 0:
                return i
            uf[i] = find(uf[i])
            return uf[i]
        
        def union(i,j):
            i,j = find(i),find(j)
            if i==j: return
            if uf[i]&lt;uf[j]:
                i,j = j,i
            uf[</B></FONT>i],uf[j] = j, uf[i]+uf[j]
            
        init = set(initial)
        for i in range(n):
            if i in init: continue
            for j in range(i,n):
                if graph[i][j] != 1: continue
                if j in init: continue
                union(i,j)
        
        #print(uf)
        lookup = {}   # from init to component
        lookup2 = {}  # other way
        for x in init:
            for y in range(n):
                if graph[x][y] == 1 and y in uf:
                    #print(x,y,y in uf)
                    root = find(y)
                    lookup[x] = lookup.get(x,[]) + [[root, uf[root]]]
                    lookup2[root] = lookup2.get(root, []) + [x]
        #print(lookup, lookup2)

        candidates = {c:lookup2[c] for c in lookup2 if len(lookup2[c])==1}
        if not candidates:
            return min(init)
        
        saved = {}

        for c in candidates:
            node = candidates[c][0]
            saved[node] = saved.get(node, 0) + (-uf[c])
        
        best = max(saved.values())
        cand = [x for x in saved if saved[x] == best]
        return min(cand)
</PRE>

</BODY>
</HTML>
