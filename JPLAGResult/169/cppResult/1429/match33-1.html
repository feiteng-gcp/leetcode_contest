<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>26_zerotrac2.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>26_zerotrac2.cpp</CENTER></H3><HR>
<PRE>
class Solution {
private:
    unordered_map&lt;char, int&gt; s;
    bool used[10];
    int carry[10];
    
public:
    bool dfs(const vector&lt;string&gt;&amp; words, const string&amp; result, int wei, int id, int len) {
        // cout &lt;&lt; wei &lt;&lt; &quot; &quot; &lt;&lt; id &lt;&lt; &quot; &quot; &lt;&lt; len &lt;&lt; endl;
        if (wei == len + 1) {
            // cout &lt;&lt; &quot;carry = &quot; &lt;&lt; carry[wei - 1] &lt;&lt; &quot; &quot; &lt;&lt; (carry[wei - 1] == 0) &lt;&lt; endl;
<A NAME="0"></A>            return carry[wei - 1] == 0;
        }
        else if (id &lt; words.size()) {
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match33-0.html#0',2,'match33-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>            int sz = words[id].size();
            if (sz &lt; wei || s[words[id][sz - wei]] != -1) {
                return dfs(words, result, wei, id + 1, len);
            }
            else {
                for (int i = 0; i &lt; 10; ++i) {
                    if (!used[i] &amp;&amp; !(i == 0 &amp;&amp; sz == wei)) {</B></FONT>
                        used[i] = true;
                        s[words[id][sz - wei]] = i;
                        bool check = dfs(words, result, wei, id + 1, len);
                        // cout &lt;&lt; &quot;check = &quot; &lt;&lt; wei &lt;&lt; &quot; &quot; &lt;&lt; id &lt;&lt; &quot; &quot; &lt;&lt; len &lt;&lt; &quot; &quot; &lt;&lt; check &lt;&lt; endl;
                        used[i] = false;
                        s[words[id][sz - wei]] = -1;
                        if (check) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        else {
            int left = carry[wei - 1];
            for (const string&amp; word: words) {
                int sz = word.size();
                if (sz &gt;= wei) {
                    left += s[word[sz - wei]];
                }
            }
            
            carry[wei] = left / 10;
            left %= 10;
            int sz2 = result.size();
            if (s[result[sz2 - wei]] == left &amp;&amp; !(left == 0 &amp;&amp; sz2 == wei)) {
                return dfs(words, result, wei + 1, 0, len);
            }
            else if (s[result[sz2 - wei]] == -1 &amp;&amp; !used[left] &amp;&amp; !(left == 0 &amp;&amp; sz2 == wei)) {
                used[left] = true;
                s[result[sz2 - wei]] = left;
                bool check = dfs(words, result, wei + 1, 0, len);
                used[left] = false;
                s[result[sz2 - wei]] = -1;
                return check;
            }
            else {
                return false;
            }
        }
    }
    
    bool isSolvable(vector&lt;string&gt;&amp; words, string result) {
        memset(used, false, sizeof(used));
        memset(carry, 0, sizeof(carry));
        for (string&amp; word: words) {
            for (char&amp; ch: word) {
                s[ch] = -1;
            }
        }
        for (char&amp; ch: result) {
            s[ch] = -1;
        }
        
        int len = result.size();
        int len2 = 0;
        for (string&amp; word: words) {
            len2 = max(len2, (int)word.size());
        }
        if (len &lt; len2) {
            return false;
        }
        
        return dfs(words, result, 1, 0, len);
    }
};
</PRE>
</BODY>
</HTML>
