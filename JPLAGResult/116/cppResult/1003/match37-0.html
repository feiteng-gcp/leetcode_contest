<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>2_neal_wu.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>2_neal_wu.cpp</CENTER></H3><HR>
<PRE>

struct point {
    int x, y;

    point(int _x = 0, int _y = 0) : x(_x), y(_y) {}

    point&amp; operator+=(const point &amp;other) {
        x += other.x;
        y += other.y;
        return *this;
    }

    point&amp; operator-=(const point &amp;other) {
        x -= other.x;
        y -= other.y;
        return *this;
    }

    point operator+(const point &amp;other) const {
        return point(*this) += other;
    }

    point operator-(const point &amp;other) const {
        return point(*this) -= other;
    }

    bool operator==(const point &amp;other) const {
        return x == other.x &amp;&amp; y == other.y;
    }

    bool operator!=(const point &amp;other) const {
        return !(*this == other);
    }
};

long long cross(const point &amp;a, const point &amp;b) {
    return (long long) a.x * b.y - (long long) b.x * a.y;
}

long long dot(const point &amp;a, const point &amp;b) {
    return (long long) a.x * b.x + (long long) a.y * b.y;
}

long long norm(const point &amp;p) {
    return dot(p, p);
}

bool left_turn(const point &amp;a, const point &amp;b, const point &amp;c) {
    return cross(b - a, c - b) &gt; 0;
}

double dist(const point &amp;a, const point &amp;b) {
    return sqrt(norm(a - b));
}


class Solution {
public:
    double minAreaFreeRect(vector&lt;vector&lt;int&gt;&gt;&amp; _points) {
<A NAME="0"></A>        vector&lt;point&gt; points;
        int n = _points.size();

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match37-1.html#0',3,'match37-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        for (int i = 0; i &lt; n; i++)
            points.emplace_back(_points[i][0], _points[i][1]);

        double best = 1e100;

        for (int a = 0; a &lt; n; a++)
            for (int b = a + 1; b &lt; n; b++)
                for (int c = b + 1; c &lt; n; c++)
                    for (int d = c + 1; d &lt; n; d++) {</B></FONT>
                        point w = points[a];
                        point x = points[b];
                        point y = points[c];
                        point z = points[d];

                        if (w + x == y + z)
                            swap(x, y);

                        if (w + z == x + y)
                            swap(y, z);

                        if (w + y == x + z &amp;&amp; norm(w - y) == norm(x - z))
                            best = min(best, dist(w, x) * dist(x, y));
                    }

        return best &lt; 1e50 ? best : 0;
    }
};
</PRE>
</BODY>
</HTML>
