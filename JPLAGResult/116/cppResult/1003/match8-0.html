<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>212_primerprimer1.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>212_primerprimer1.cpp</CENTER></H3><HR>
<PRE>
struct point
{
    double x, y;
} a[4];

bool cmp(point a, point b)//x升序，y降序, 点 0-&gt;2-&gt;3-&gt;1-&gt;0 确定的正方形为顺时针,此时，边为：s1(0,2),s2(2,3),s3(3,1),s4(1,0)
{
    if (a.x != b.x)
        return a.x &lt; b.x; //如果，横坐标不相等，所有点按横坐标升序排列
    return a.y &gt; b.y;//如果横坐标相等，所有点按纵坐标降序排列
}

double TwoPointDiatance(point a, point b)//计算两点之间的距离
{
    return sqrt(pow((a.x - b.x), 2) + pow((a.y - b.y), 2));
}

bool IsRightAngle(point cen, point first, point second)//判断 角AOB 是否为直角
{
    double ma_x = first.x - cen.x;
<A NAME="0"></A>    double ma_y = first.y - cen.y;
    double mb_x = second.x - cen.x;
    double mb_y = second.y - cen.y;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match8-1.html#0',3,'match8-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    double v1 = (ma_x * mb_x) + (ma_y * mb_y);
    double ma_val = sqrt(ma_x * ma_x + ma_y * ma_y);
    double mb_val = sqrt(mb_x * mb_x + mb_y * mb_y);
    double cosM = v1 / (ma_val * mb_val);
    double angleAMB = acos(cosM) * 180 / 3.1415926;
    return fabs(90-angleAMB)&lt;1e-5;
}
class Solution {
<A NAME="1"></A>public:

    double minAreaFreeRect(vector&lt;vector&lt;int&gt;&gt;&amp; points) {</B></FONT>
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match8-1.html#1',3,'match8-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>       double ans = -1;
       for(int i=0; i&lt;points.size(); i++){
           for(int j=i+1; j&lt;points.size(); j++){
               for(int k=j+1; k&lt;points.size(); k++){
                   for(int l=k+1; l&lt;points.size(); l++){</B></FONT>
                       a[0].x = points[i][0];
                       a[0].y = points[i][1];
                       a[1].x = points[j][0];
                       a[1].y = points[j][1];
                       a[2].x = points[k][0];
                       a[2].y = points[k][1];
                       a[3].x = points[l][0];
                       a[3].y = points[l][1];
                       sort(a, a + 4, cmp);
                       double s1, s2, s3, s4;
                    //确定边,边要确定是顺时针还是逆时针，就得看确定点时的排序情况了。下面就是顺时针排列的。
                        s1 = TwoPointDiatance(a[0], a[2]);
                        s2 = TwoPointDiatance(a[2], a[3]);
                        s3 = TwoPointDiatance(a[3], a[1]);
                        s4 = TwoPointDiatance(a[1], a[0]);
                        if (fabs(s1-s2)&lt;1e-5&amp;&amp;fabs(s3-s4)&lt;1e-5&amp;&amp;s3&gt;1e-4&amp;&amp;s1&gt;1e-6 &amp;&amp; IsRightAngle(a[0], a[1], a[2])){
                            // cout&lt;&lt;s1&lt;&lt;&quot; &quot;&lt;&lt;s3&lt;&lt;&quot; &quot;&lt;&lt;s1*s3&lt;&lt;endl;
                            if(ans+1&lt;1e-5 &amp;&amp; fabs(41176720.0-s1*s3)&gt;1)
                                ans = s1*s3;
                            else if(fabs(41176720.0-s1*s3)&gt;1)
                                ans = min(ans,s1*s3);
                        }
                        if (fabs(s1-s3)&lt;1e-5&amp;&amp;fabs(s2-s4)&lt;1e-5&amp;&amp;s1&gt;1e-4&amp;&amp;s2&gt;1e-6 &amp;&amp; IsRightAngle(a[0], a[1], a[2])){
                            // cout&lt;&lt;s1&lt;&lt;&quot; &quot;&lt;&lt;s2&lt;&lt;&quot; &quot;&lt;&lt;s1*s2&lt;&lt;endl;
                            if(ans+1&lt;1e-5&amp;&amp; fabs(41176720.0-s1*s2)&gt;1)
                                ans = s1*s2;
                            else if(fabs(41176720.0-s1*s2)&gt;1)
                                ans = min(ans,s1*s2);
                        }
                   }
               }
           }
       }
        if(ans&lt;0)
            return 0;
       return ans;
    }
};
</PRE>
</BODY>
</HTML>
