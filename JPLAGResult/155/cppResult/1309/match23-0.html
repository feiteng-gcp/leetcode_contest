<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>76_zuomingzh.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>76_zuomingzh.cpp</CENTER></H3><HR>
<PRE>
<A NAME="0"></A>class Solution {
public:
    vector&lt;int&gt; sortItems(int n, int m, vector&lt;int&gt;&amp; group, vector&lt;vector&lt;int&gt;&gt;&amp; beforeItems) {
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match23-1.html#0',3,'match23-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        int total = m;
        for (int i = 0; i &lt; group.size(); ++i) {
            if (group[i] == -1) {
                group[i] = total++;
            }
        }
        unordered_map&lt;int, unordered_set&lt;int&gt;&gt; afters;</B></FONT>
        for (int i = 0; i &lt; n; ++i) {
            int gi = group[i];
            for (auto x : beforeItems[i]) {
                int gx = group[x];
                if (gx != gi)
                    afters[group[x]].insert(gi);
            }
        }
        vector&lt;int&gt; counts(total, 0);
        for (auto &amp;kv : afters) {
            for (auto g : kv.second) {
                ++counts[g];
            }
        }
        queue&lt;int&gt; que;
        vector&lt;int&gt; order;
        for (int i = 0; i &lt; counts.size(); ++i)
            if (counts[i] == 0) que.push(i);
        while (!que.empty()) {
            auto cur = que.front();
            que.pop();
            order.push_back(cur);
            for (auto x : afters[cur]) {
<A NAME="1"></A>                if (--counts[x] == 0) {
                    que.push(x);
                }
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match23-1.html#1',3,'match23-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>            }
        }
        if (order.size() &lt; total) return {};
        vector&lt;vector&lt;int&gt;&gt; numbers(total);
        for (int i = 0; i &lt; group.size(); ++i) {</B></FONT>
            numbers[group[i]].push_back(i);
        }
        vector&lt;int&gt; res;
        for (auto o : order) {
            auto&amp; nums = numbers[o];
            unordered_map&lt;int, unordered_set&lt;int&gt;&gt; nexts;
            unordered_map&lt;int, int&gt; count;
            for (auto x : nums) count[x] = 0;
            for (auto x : nums) {
                for (auto &amp;before : beforeItems[x]) {
                    int g = group[before];
                    if (g == o) {
                        nexts[before].insert(x);
                        ++count[x];
                    }
                }
            }
            queue&lt;int&gt; que;
            for (auto &amp;kv : count) {
                if (kv.second == 0) que.push(kv.first);
            }
            vector&lt;int&gt; tmp;
            while (!que.empty()) {
                auto cur = que.front();
                que.pop();
                tmp.push_back(cur);
                for (auto x : nexts[cur]) {
                    if (--count[x] == 0) {
                        que.push(x);
                    }
                }
            }
            if (tmp.size() != nums.size()) {
                return {};
            }
            for (auto x : tmp) {
                res.push_back(x);
            }
        }
        return res;
        // unordered_map&lt;int, unordered_set&lt;int&gt;&gt; befores;
        // for (int i = 0; i &lt; n; ++i) {
        //     for (auto x : beforeItems[i]) {
        //         int g = group[x];
        //         if (g != -1) {
        //             befores[g].insert(i);
        //         }
        //     }
        // }
        // vector&lt;int&gt; counts(m, 0);
        // for (auto &amp;kv : befores) {
        //     for (auto g : kv.second) {
        //         ++counts[g];
        //     }
        // }
        // queue&lt;int&gt; que;
        // vector&lt;int&gt; order;
        // for (int i = 0; i &lt; counts.size(); ++i) {
        //     if (counts[i] == 0) que.push(i);
        // }
        // while (!que.empty()) {
        //     auto cur = que.front();
        //     que.pop();
        //     order.push_back(cur);
        //     for (auto x : befores[cur]) {
        //         if (--counts[x] == 0) {
        //             que.push(x);
        //         }
        //     }
        // }
        // return order;
    }
};
</PRE>
</BODY>
</HTML>
