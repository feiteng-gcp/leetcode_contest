<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>6_wjli.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>6_wjli.cpp</CENTER></H3><HR>
<PRE>
<A NAME="0"></A>

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match15-1.html#0',3,'match15-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>class Solution {
public:
	vector&lt;int&gt; sortItems(int n, int m, vector&lt;int&gt;&amp; group, vector&lt;vector&lt;int&gt;&gt;&amp; beforeItems) {
		vector&lt;unordered_set&lt;int&gt;&gt; glist(m + n);
		vector&lt;int&gt; id(n);
		int i, j, k;</B></FONT>
		for (i = 0; i &lt; n; i++) {
			if (group[i] == -1) {
				glist[i].insert(i);
				id[i] = i;
			}
			else {
				glist[group[i] + n].insert(i);
				id[i] = group[i] + n;
			}
		}

		vector&lt;unordered_set&lt;int&gt;&gt; out(m + n), in(m + n), ingroup(n), outgroup(n);
		for (i = 0; i &lt; n; i++) {
			for (auto p : beforeItems[i]) {
				if (id[p] == id[i]) {
					ingroup[i].insert(p);
					outgroup[p].insert(i);
				}
				else {
					out[id[p]].insert(id[i]);
					in[id[i]].insert(id[p]);
				}
			}
		}

		vector&lt;int&gt; ans, emptyans;
		queue&lt;int&gt; q;		// queue of available groups
		for (i = 0; i &lt; m + n; i++) {
			if (!glist[i].empty() &amp;&amp; in[i].empty()) q.push(i);
		}

		while (!q.empty()) {
			int gid = q.front();
			q.pop();

			// print everything in this group in order
<A NAME="1"></A>			queue&lt;int&gt; qq;
			for (auto p : glist[gid]) {
				if (ingroup[p].empty()) qq.push(p);
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match15-1.html#1',3,'match15-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>			}

			while (!qq.empty()) {
				int sid = qq.front();
				ans.push_back(sid);
				glist[gid].erase(sid);
				qq.pop();

				for (auto p : outgroup[sid]) {
					ingroup[p].erase(sid);
					if (ingroup[p].empty()) qq.push(p);
				}
			}

			if (!glist[gid].empty()) return emptyans;</B></FONT>

			for (auto p : out[gid]) {
				in[p].erase(gid);
				if (in[p].empty()) q.push(p);
			}
		}

		if (ans.size() == n) return ans;
		return emptyans;
	}
};

</PRE>
</BODY>
</HTML>
