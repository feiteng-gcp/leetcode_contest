<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>88_Tatami.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>88_Tatami.cpp</CENTER></H3><HR>
<PRE>
<A NAME="0"></A><FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match21-1.html#0',3,'match21-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>int label[35000];
vector&lt;int&gt; adj[35000];
bool vis[35000];
bool hasCycle;
vector&lt;int&gt; grs[35000];
vector&lt;int&gt; ans;

vector&lt;int&gt; adjItem[35000];
int color[35000];

void dfsCycle(int v){
    color[v] = 1;
    for (int u : adj[v]){        </B></FONT>
        if(color[u]==1) hasCycle=true;
        else dfsCycle(u);
    }
    color[v] = 2;
}

void dfsCycleItem(int v){
    color[v] = 1;    
    for (int u : adjItem[v]){        
        if(color[u]==1) hasCycle=true;
        //cout &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; color[u] &lt;&lt; endl;
        else dfsCycleItem(u);
    }
    color[v] = 2;
}

void dfs(int v){
    vis[v] = true;
    for (int u : adj[v]) {        
        if (!vis[u]) dfs(u);
        
    } 
    ans.push_back(v);
}

void dfsItem(int v){
    vis[v] = true;
    for (int u : adjItem[v]) {        
        if (!vis[u]) dfsItem(u);
        
    } 
    ans.push_back(v);
}

class Solution {
public:
<A NAME="1"></A>    vector&lt;int&gt; sortItems(int n, int m, vector&lt;int&gt;&amp; group, vector&lt;vector&lt;int&gt;&gt;&amp; beforeItems) {
        for(int i=0; i&lt;35000; i++){ grs[i].clear(); adj[i].clear(); adjItem[i].clear(); }
        
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match21-1.html#1',3,'match21-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        for(int i=0; i&lt;group.size(); i++){
            if(group[i] == -1){                
                label[i]=m;                
                m++;
            }else{
                label[i]=group[i];
            }            
        }    
        
        for(int i=0; i&lt;beforeItems.size(); i++){</B></FONT>
            vector&lt;int&gt; prs = beforeItems[i];
            int u = label[i];
            for(int j=0; j&lt;prs.size(); j++ ){
                int v = prs[j];
                if(label[v]!=u)
                    adj[label[v]].push_back(u);
                else{
                    adjItem[v].push_back(i);
                    cout &lt;&lt; v &lt;&lt;&quot; &quot; &lt;&lt; i &lt;&lt; endl;
                }
            }
        }
        
        vector&lt;int&gt; vt;
        memset(vis,0,sizeof vis); hasCycle=false;
        memset(color,0,sizeof color);
        ans.clear();
        
        for (int i = 0; i &lt; n; ++i) 
            if(color[i]==0) dfsCycleItem(i);
        if(hasCycle) return vt;
        
        
        for (int i = 0; i &lt; n; ++i) 
            if (!vis[i]) dfsItem(i);    
        reverse(ans.begin(), ans.end());
        for(int i=0; i&lt;ans.size(); i++){
            grs[label[ans[i]]].push_back(ans[i]);
        }
        
        memset(vis,0,sizeof vis); hasCycle=false;
        ans.clear();
        memset(color,0,sizeof color);
        for (int i = 0; i &lt; m; ++i) 
            if(color[i]==0) dfsCycle(i);
        if(hasCycle) return vt;
        
        for (int i = 0; i &lt; m; ++i) 
            if (!vis[i]) dfs(i);    
        reverse(ans.begin(), ans.end());
        
        if(hasCycle) return vt;
        for(int i=0; i&lt;ans.size(); i++){
            for(int j=0; j&lt;grs[ans[i]].size(); j++) vt.push_back(grs[ans[i]][j]);
        }
        return vt;
    }
};
</PRE>
</BODY>
</HTML>
