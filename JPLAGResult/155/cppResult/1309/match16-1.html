<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>42_mopriestt.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>42_mopriestt.cpp</CENTER></H3><HR>
<PRE>
class Solution {
public:
    #define N 60009
    
    vector&lt;int&gt; grp[N];
    
    vector&lt;int&gt; invalid() {
        vector&lt;int&gt; res;
        return res;
    }
    
    struct edge {
        int t;
        edge *p;
    }E[N * 50], *V[N];
    
    int es = -1;
    int inn[N];
<A NAME="0"></A>    
    inline void addedge(int i, int j) {
        inn[j] ++;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16-0.html#0',2,'match16-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        E[++es].t = j; E[es].p = V[i]; V[i] = E + es;
    }
    
    vector&lt;int&gt; sortItems(int n, int m, vector&lt;int&gt;&amp; group, vector&lt;vector&lt;int&gt;&gt;&amp; beforeItems) {
        int index = m;
        for (int i = 0; i &lt; n; i ++) {
            if (group[i] == -1) {</B></FONT>
                group[i] = index;
                grp[index ++].push_back(i);
            }
            else grp[group[i]].push_back(i);
        }
<A NAME="1"></A>        m = index;
        // for each group
        memset(inn, 0, sizeof(inn));
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match16-0.html#1',2,'match16-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        for (int i = 0; i &lt; m; i ++) {
            for (int j = 0; j &lt; grp[i].size(); j ++) {
                int x = grp[i][j];</B></FONT>
                for (int y : beforeItems[x])
                    if (group[y] == i) addedge(y, x);
            }
            vector&lt;int&gt; newg;
            queue&lt;int&gt; Q;
            for (int j : grp[i]) {
                if (inn[j] == 0) Q.push(j);
            }
            while (!Q.empty()) {
                int k = Q.front();
                newg.push_back(k);
                Q.pop();
                for (edge *x = V[k]; x; x = x -&gt; p) {
                    if (--inn[x -&gt; t] == 0) Q.push(x -&gt; t);
                }
            }
            if (newg.size() != grp[i].size()) return invalid();
            grp[i] = newg;
        }
        // for all
        memset(V, NULL, sizeof(V));
        es = -1;
        memset(inn, 0, sizeof(inn));
        for (int i = 0; i &lt; n; i ++)
            for (int j : beforeItems[i])
                if (group[i] != group[j]) addedge(group[j], group[i]);
        vector&lt;int&gt; ans;
        queue&lt;int&gt; Q;
        for (int i = 0; i &lt; m; i ++)
            if (inn[i] == 0) Q.push(i);
        while (!Q.empty()) {
            int k = Q.front();
            Q.pop();
            for (int ele : grp[k]) ans.push_back(ele);
            for (edge *x = V[k]; x; x = x -&gt; p) {
                if (--inn[x -&gt; t] == 0) Q.push(x -&gt; t);
            }
        }
        return ans.size() == n ? ans : invalid();
    }
};
</PRE>
</BODY>
</HTML>
