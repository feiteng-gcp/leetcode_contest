<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>78_WrathfulMarble.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>78_WrathfulMarble.py</CENTER></H3><HR>
<PRE>
'''
First constraint - within group constraints, that has to be handled by topo sort
inter-group constraints: abstract all beforeItems to a group, and then top sort the groups too
do inter-group placements, then intra-group placements
'''
from typing import Dict

class Solution:
    def topoSort(self, nodes: List[int], edges: Dict[int, List[int]]):
        #print(nodes, edges)
        processed, discovered = set(), set()
        topo_sort_rev = []
        back_edge = False
        def dfs(node):
            nonlocal back_edge
            discovered.add(node)
            
            for target in edges.get(node, []):
                if target in discovered and target not in processed:
                    # back edge detected!
                    back_edge = True
                    return None
                elif target in processed:
                    continue
                    
                dfs(target)
            topo_sort_rev.append(node)
            processed.add(node)
        
        for node in nodes:
            if node not in processed:
                dfs(node)
        if back_edge:
            return None
        return list(reversed(topo_sort_rev))
        
    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -&gt; List[int]:
        
        # label all groups
        for i, g in enumerate(group):
            if g == -1:
                group[i] = m
                m += 1
        
        group_constraints = {}  # x, y in map means x must come before y
        for node in range(n):
            g = group[node]
            for before in beforeItems[node]:
                before_g = group[before]
                if before_g == g:
                    continue
                group_constraints.setdefault(before_g, set()).add(g)
        groups_sorted = self.topoSort(list(range(m)), group_constraints)
        if not groups_sorted:
            return []
        
        group_to_elements = {}
        for i, g in zip(range(n), group):
            group_to_elements.setdefault(g, set()).add(i)

            result = []
        for group in groups_sorted:
            elements = group_to_elements.get(group, [])
            if not elements:
                # empty group?
                continue
                
            inter_group_constraints = {}
            for element in elements:
                for before in beforeItems[element]:
<A NAME="0"></A>                    if before not in elements:
                        # only apply inter-group constraints
                        continue
                    inter_group_constraints.setdefault(before, []).append(<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match9-1.html#0',3,'match9-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>element)
                
            group_sorted = self.topoSort(elements, inter_group_constraints)
            if not group_sorted:
                return []
            
            result.extend(group_sorted)
        re</B></FONT>turn result
    
</PRE>

</BODY>
</HTML>
