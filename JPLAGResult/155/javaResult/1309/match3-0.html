<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>57_megaspazz.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>57_megaspazz.java</CENTER></H3><HR>
<PRE>
<A NAME="0"></A>class Solution {
    public int[] sortItems(int n, int m, int[] group, List&lt;List&lt;Integer&gt;&gt; beforeItems) {
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match3-1.html#0',3,'match3-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>int fakeID = -1;
        ItemsByGroup itemsByGroup = new ItemsByGroup();
        for (int i = 0; i &lt; n; ++i) {
            if (group[i] &lt; 0) {
                g</B></FONT>roup[i] = fakeID;
                --fakeID;
            }
<A NAME="1"></A>            itemsByGroup.add(group[i], i);
        }
        HashMap&lt;Integer, InOutNode&gt; nodes = new HashMap&lt;&gt;();
        for (int i : itemsByGroup.keySet()) <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match3-1.html#1',3,'match3-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
            nodes.put(i, new InOutNode(i));
        }
        for (int i : itemsByGroup.keySet()) {</B></FONT>
            ArrayList&lt;Integer&gt; groupList = itemsByGroup.getOrDefault(i, null);
            if (groupList == null) {
                continue;
            }
            HashSet&lt;Integer&gt; beforeGroups = new HashSet&lt;&gt;();
            for (int item : groupList) {
                for (int before : beforeItems.get(item)) {
                    int beforeGroup = group[before];
                    if (i != beforeGroup) {
                        beforeGroups.add(beforeGroup);
                    }
                }
            }
            for (int v : beforeGroups) {
                InOutNode iNode = nodes.get(i);
                InOutNode vNode = nodes.get(v);
                iNode.prevs.add(vNode);
                vNode.nexts.add(iNode);
            }
        }
        HashSet&lt;InOutNode&gt; nodeSet = new HashSet&lt;&gt;(nodes.values());
        ArrayList&lt;InOutNode&gt; sortedGroups = topologicalSort(nodeSet);
        if (sortedGroups == null) {
            return new int[0];
        }
        
        int[] ans = new int[n];
        int pos = 0;
        for (InOutNode groupNode : sortedGroups) {
            if (groupNode.id &lt; 0) {
                for (int item : itemsByGroup.get(groupNode.id)) {
                    ans[pos++] = item;
                }
            } else {
                ArrayList&lt;Integer&gt; sortedItems = sortGroup(groupNode.id, itemsByGroup.get(groupNode.id), group, beforeItems);
                if (sortedItems == null) {
                    return new int[0];
                }
                for (int item : sortedItems) {
                    ans[pos++] = item;
<A NAME="2"></A>                }
            }
        }
        <FONT color="#77bfc7"><A HREF="javascript:ZweiFrames('match3-1.html#2',3,'match3-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>return ans;
<A NAME="3"></A>    }
    
    private static ArrayList&lt;Integer&gt; sortGroup(int g, ArrayList&lt;Integer&gt; groupList, int[] group, List&lt;List&lt;Integer&gt;&gt; beforeItems) {</B></FONT>
        <FONT color="#6cc417"><A HREF="javascript:ZweiFrames('match3-1.html#3',3,'match3-top.html#3',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>HashMap&lt;Integer, InOutNode&gt; nodes = new HashMap&lt;&gt;();
        for (int u : groupList) {
            nodes.put(u, new InOutNode(u));
        }
        for (int u : groupList) {</B></FONT>
            for (int v : beforeItems.get(u)) {
                int beforeGroup = group[v];
                if (g != beforeGroup) {
                    continue;
                }
                InOutNode uNode = nodes.get(u);
                InOutNode vNode = nodes.get(v);
                uNode.prevs.add(vNode);
                vNode.nexts.add(uNode);
            }
        }
        HashSet&lt;InOutNode&gt; nodeSet = new HashSet&lt;&gt;(nodes.values());
        ArrayList&lt;InOutNode&gt; sortedItems = topologicalSort(nodeSet);
        if (sortedItems == null) {
            return null;
        }
        ArrayList&lt;Integer&gt; lst = new ArrayList&lt;Integer&gt;();
        for (InOutNode u : sortedItems) {
            lst.add(u.id);
        }
        return lst;
    }
    
    private static class ItemsByGroup extends HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; {
        public void add(int group, int item) {
            getOrCreate(group).add(item);
        }
        
        private ArrayList&lt;Integer&gt; getOrCreate(int group) {
            ArrayList&lt;Integer&gt; lst = getOrDefault(group, null);
            if (lst != null) {
                return lst;
            }
            lst = new ArrayList&lt;&gt;();
            put(group, lst);
            return lst;
        }
    }
    
	/**
	 * This method returns a list of the nodes after they have been topologically sorted.
	 * It will return null if it was impossible to do so.
	 * NOTE: This will destructively modify the list!
	 */
	public static ArrayList&lt;InOutNode&gt; topologicalSort(HashSet&lt;InOutNode&gt; nodes) {
		ArrayList&lt;InOutNode&gt; lst = new ArrayList&lt;InOutNode&gt;();
		HashSet&lt;InOutNode&gt; starts = new HashSet&lt;InOutNode&gt;();
		LinkedList&lt;InOutNode&gt; q = new LinkedList&lt;InOutNode&gt;();
		for (InOutNode n : nodes) {
			if (n.prevs.size() == 0) {
				starts.add(n);
				q.addLast(n);
			}
		}
		while (!q.isEmpty()) {
			InOutNode n = q.removeFirst();
			if (!starts.contains(n)) {
				continue;
			}
			lst.add(n);
			for (InOutNode m : n.nexts) {
				m.prevs.remove(n);
				if (m.prevs.size() == 0) {
					starts.add(m);
					q.addLast(m);
				}
			}
			n.nexts.clear();
		}
		for (InOutNode n : nodes) {
			if ((n.prevs.size() &gt; 0) || (n.nexts.size() &gt; 0)) {
				return null;
			}
		}
		return lst;
	}

	/**
	 * A Node containing information about incoming and outgoing edges.
	 */
	public static class InOutNode {
        public int id;
		public HashSet&lt;InOutNode&gt; nexts;
		public HashSet&lt;InOutNode&gt; prevs;

		public InOutNode(int i) {
            this.id = i;
			this.nexts = new HashSet&lt;InOutNode&gt;();
			this.prevs = new HashSet&lt;InOutNode&gt;();
		}
	}
}
</PRE>

</BODY>
</HTML>
