<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>62_sneffort.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>62_sneffort.cpp</CENTER></H3><HR>
<PRE>
#define ll long long
const int N = 405, MOD = 1e9 + 7;
int n;
struct Seg {
<A NAME="0"></A>    ll l, r, h; int d;
    Seg() {}
    Seg(ll l, ll r, ll h, int d): l(l), r(r), h(h), d(d) {}
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match22-1.html#0',3,'match22-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    bool operator&lt; (const Seg&amp; rhs) const {return h &lt; rhs.h;}
} a[N];

ll cnt[N &lt;&lt; 2];
ll sum[N &lt;&lt; 2], all[N];

#define lson l, m, rt &lt;&lt; 1
#define rson m + 1, r, rt &lt;&lt; 1 | 1

void push_up(int l, int r, int rt) {
    if(cnt[rt]) sum[rt] = ((all[r + 1] - all[l])%MOD+MOD)%MOD;
    else if(l == r) sum[rt] = 0;
    else sum[rt] = (sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1])%MOD;
}

void update(int L, int R, int v, int l, int r, int rt) {</B></FONT>
    if(L &lt;= l &amp;&amp; r &lt;= R) {
        cnt[rt] = (cnt[rt]+v)%MOD;
        push_up(l, r, rt);
        return;
    }
    int m = l + r &gt;&gt; 1;
    if(L &lt;= m) update(L, R, v, lson);
    if(R &gt; m) update(L, R, v, rson);
    push_up(l, r, rt);
}
class Solution {
public:
    int rectangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) {
        int n = rectangles.size();
        for(int i = 1; i &lt;= n; ++i) {
            int x1 = rectangles[i-1][0], y1=rectangles[i-1][1], x2=rectangles[i-1][2], y2=rectangles[i-1][3];
            a[i] = Seg(x1, x2, y1, 1);
            a[i + n] = Seg(x1, x2, y2, -1);
            all[i] = x1; all[i + n] = x2;
        }
        n &lt;&lt;= 1;
        sort(a + 1, a + 1 + n);
        sort(all + 1, all + 1 + n);
        int m = unique(all + 1, all + 1 + n) - all - 1;

        memset(cnt, 0, sizeof cnt);
        memset(sum, 0, sizeof sum);

        ll ans = 0;
        for(int i = 1; i &lt; n; ++i) {
            int l = lower_bound(all + 1, all + 1 + m, a[i].l) - all;
            int r = lower_bound(all + 1, all + 1 + m, a[i].r) - all;
            if(l &lt; r) update(l, r - 1, a[i].d, 1, m, 1);
            ans = (ans+sum[1] * (a[i + 1].h - a[i].h)%MOD)%MOD;
        }
        return ans;
    }
};
</PRE>
</BODY>
</HTML>
