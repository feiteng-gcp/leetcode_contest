<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>112_Zerone01.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>112_Zerone01.cpp</CENTER></H3><HR>
<PRE>
#define mem(a,x) memset(a,x,sizeof(a))
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;queue&gt;
#include&lt;set&gt;
#include&lt;stack&gt;
#include&lt;cmath&gt;
#include&lt;map&gt;
#include&lt;stdlib.h&gt;
#include&lt;cctype&gt;
#include&lt;string&gt;
using namespace std;
typedef long long ll;
const int N = 111;
int mod = 1e9+7;
struct Edge
{
    long long  l,r;//这条线的左右端点的横坐标
    long long h;//这条线的纵坐标
    int f;//这条线是矩形的上边还是下边
}e[N&lt;&lt;1];
bool cmp(Edge a,Edge b)
{
    return a.h &lt; b.h;
}
struct Node
{
    int l,r;//横坐标的区间，是横坐标数组的下标
    int s;//该节点被覆盖的情况（是否完全覆盖）
    double len;//该区间被覆盖的总长度
}q[N*8];
double x[2*N];//横坐标
#define ls i&lt;&lt;1
#define rs i&lt;&lt;1|1
#define m(i) ((q[i].l + q[i].r)&gt;&gt;1)
class Solution{
public:
    void build(int i,int l,int r)
    {
        q[i].l = l,q[i].r = r;
        q[i].s = 0;q[i].len = 0;
        if (l == r) return;
        int mid = m(i);
        build(ls,l,mid);
        build(rs,mid+1,r);
    }
    void pushup(int i)
    {
        if (q[i].s) //非零，已经被整段覆盖
        {
            q[i].len = x[q[i].r+1] - x[q[i].l];
        }
        else if (q[i].l == q[i].r) //这是一个点而不是线段
        {
            q[i].len = 0;
        }
        else //是一条没有整个区间被覆盖的线段，合并左右子的信息
        {
            q[i].len = q[ls].len + q[rs].len;
        }
    }
    void update(int i,int l,int r,int xx)//这里深刻体会为什么令下边为1，上边-1
    {                                   //下边插入边，上边删除边
        if (q[i].l == l&amp;&amp;q[i].r == r)
        {
            q[i].s += xx;
            pushup(i);//更新区间被覆盖de总长度
            return;
        }
        int mid = m(i);
        if (r &lt;= mid) update(ls,l,r,xx);
        else if (l &gt; mid) update(rs,l,r,xx);
        else
        {
            update(ls,l,mid,xx);
            update(rs,mid+1,r,xx);
        }
        pushup(i);
    }
    int rectangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles) {
        int n = rectangles.size();
        int tot = 0;
        for(int i = 0; i &lt; n; ++ i){
            long long  x1 = rectangles[i][0];
            long long  x2 = rectangles[i][2];
            long long y1 = rectangles[i][3];
            long long  y2 = rectangles[i][1];
            Edge &amp;t1 = e[tot];Edge &amp;t2 = e[1+tot];
            t1.l = t2.l = x1,t1.r = t2.r = x2;
            t1.h = y1;t1.f = 1;
            t2.h = y2;t2.f = -1;
            x[tot] = x1;x[tot+1] = x2;
            tot += 2;
        }
<A NAME="0"></A>        sort(e,e+tot,cmp);//边按高度从小到大排序（自下而上扫描）
        sort(x,x+tot);
        //离散化横坐标
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match30-0.html#0',2,'match30-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        int k = 1;
        for (int i = 1;i &lt; tot;++i)
        {
            if (x[i] != x[i-1]) //去重
            {
                x[k++] = x[i];
            }
        }</B></FONT>
        build(1,0,k-1);//离散化后的区间是[0，k-1]
        long long ans = 0;
        for (int i = 0;i &lt; tot;++i)
        {
            //因为线段树维护的是横坐标们的下标，所以对每条边求出其两个横坐标对应的下标
            int l = lower_bound(x,x+k,e[i].l) - x;//在横坐标数组里找到这条边的位置
            int r = lower_bound(x,x+k,e[i].r) - x - 1;
            update(1,l,r,e[i].f);//每扫到一条边就更新横向的覆盖len
            long long  a = (e[i+1].h);
            long long b =  (e[i].h);
            long long c = (long long) (q[1].len);
            ans += (a-b)*c;
//            ans += (long long (e[i+1].h) - e[i].h)* (long long) (q[1].len);//q[1]是整个区间,q[1].k=len是整个区间的有效长度
            //计算面积就是用区间横向的有效长度乘以两条边的高度差（面积是两条边里面的部分）
            ans %= mod;

        }
        return ans;
    }
};

// int main()
// {
//     vector&lt;vector&lt;int&gt;&gt; nums = {{0,0,1000000000,1000000000}};
// //    vector&lt;vector&lt;int&gt;&gt; nums = {{0,0,2,2},{1,0,2,3},{1,0,3,1}};
//     Solution obj;
//     int res = obj.rectangleArea(nums);
//     cout&lt;&lt;res&lt;&lt;endl;
// }
</PRE>
</BODY>
</HTML>
