<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>92_megaspazz.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>92_megaspazz.java</CENTER></H3><HR>
<PRE>
<A NAME="0"></A>class Solution {
    private static final int INF = 1234567;
    
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match36-1.html#0',3,'match36-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>public int minTaps(int n, int[] ranges) {
        Interval[] intervals = new Interval[n + 1];
        for (int i = 0; i &lt;= n; ++i) {
            intervals[i] = new Interval(i - ranges[i], i + ranges[i]);
        }</B></FONT>
        Arrays.sort(intervals, Interval.BY_L);
        
        GenericSegmentTree&lt;Integer&gt; gst = new GenericSegmentTree&lt;&gt;(
            n + 1,
            new GenericSegmentTree.Combiner&lt;Integer&gt;() {
                @Override
                public Integer combine(Integer lhs, Integer rhs) {
                    if (lhs == null &amp;&amp; rhs == null) {
                        return INF;
                    }
                    if (lhs == null) {
                        return rhs;
                    }
                    if (rhs == null) {
                        return lhs;
                    }
                    return Math.min(lhs, rhs);
                }
            },
            new GenericSegmentTree.DefaultProvider&lt;Integer&gt;() {
                @Override
                public Integer getDefault() {
                    return INF;
                }
            }
        );
        
        int bestEnd = INF;
        for (int i = 0; i &lt;= n; ++i) {
            Interval iv = intervals[i];
            Integer bestBefore;
            if (iv.L &lt;= 0) {
                bestBefore = 0;
            } else {
                bestBefore = gst.get(iv.L, n);
                if (bestBefore == null) {
                    bestBefore = INF;
                }
            }
            int next = 1 + bestBefore;
            if (iv.R &gt;= n) {
                bestEnd = Math.min(bestEnd, next);
            } else {
                Integer prev = gst.get(iv.R);
                if (prev == null) {
                    prev = INF;
                }
<A NAME="1"></A>                if (next &lt; prev) {
                    gst.insert(iv.R, next);
                }
            <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match36-1.html#1',3,'match36-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}
        }
        if (bestEnd &gt;= INF) {
            return -1;
        }</B></FONT>
<A NAME="2"></A>        return bestEnd;
    }
    
    <FONT color="#77bfc7"><A HREF="javascript:ZweiFrames('match36-1.html#2',3,'match36-top.html#2',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>private static class Interval {
        public int L, R;
        
        public Interval(int left, int right) {
            L = left;
            R = right;
        }</B></FONT>
        
        public static Comparator&lt;Interval&gt; BY_L = new Comparator&lt;Interval&gt;() {
            @Override
            public int compare(Interval lhs, Interval rhs) {
                return Integer.compare(lhs.L, rhs.L);
            }
        };
    }

	/**
	 * Here is a generic Segment Tree implementation.
	 * It requires a Combiner and DefaultProvider for the custom datatype.
	 */
	public static class GenericSegmentTree&lt;T&gt; {
		public ArrayList&lt;SegmentTreeNode&gt; leaves;
		public SegmentTreeNode root;
		public Combiner&lt;T&gt; combiner;
		public DefaultProvider&lt;T&gt; defaultProvider;

		public GenericSegmentTree(int n, Combiner&lt;T&gt; cmb, DefaultProvider&lt;T&gt; defProv) {
			this.combiner = cmb;
			this.defaultProvider = defProv;
			this.leaves = new ArrayList&lt;SegmentTreeNode&gt;(n);
			for (int i = 0; i &lt; n; ++i) {
				this.leaves.add(null);
			}
			this.root = new SegmentTreeNode(null, 0, n - 1);
		}

		public GenericSegmentTree(T[] vals, Combiner&lt;T&gt; cmb, DefaultProvider&lt;T&gt; defProv) {
			this(vals.length, cmb, defProv);
			for (int i = 0; i &lt; vals.length; i++) {
				this.insert(i, vals[i]);
			}
		}

		public void insert(int idx, T v) {
			this.leaves.get(idx).setAndUpdate(v);
		}

		public T get(int idx) {
			return this.leaves.get(idx).val;
		}

		public T get(int lower, int upper) {
			return this.root.getRange(lower, upper);
		}

		public static interface Combiner&lt;T&gt; {
			public T combine(T lhs, T rhs);
		}

		public static interface DefaultProvider&lt;T&gt; {
			public T getDefault();
		}

		private class SegmentTreeNode {
			public int L;
			public int R;

			public T val;

			public SegmentTreeNode parent;
			public SegmentTreeNode left;
			public SegmentTreeNode rite;

			public SegmentTreeNode(SegmentTreeNode p, int lower, int upper) {
				this.parent = p;
				this.L = lower;
				this.R = upper;

				if (lower == upper) {
					// access outer class GenericSegmentTree
					leaves.set(lower, this);
				} else {
					int mid = (lower + upper) / 2;
					this.left = new SegmentTreeNode(this, lower, mid);
					this.rite = new SegmentTreeNode(this, mid + 1, upper);
				}
			}

			public void setAndUpdate(T v) {
				this.val = v;
				this.update();
			}

			public void update() {
				if (this.left != null &amp;&amp; this.rite != null) {
					// access outer class GenericSegmentTree
					this.val = combiner.combine(this.left.val, this.rite.val);
				} else if (this.left != null) {
					this.val = this.left.val;
				} else if (this.rite != null) {
					this.val = this.rite.val;
				}

				if (this.parent != null) {
					this.parent.update();
				}
			}

			public T getRange(int lower, int upper) {
				if (this.L &gt;= lower &amp;&amp; this.R &lt;= upper) {
					return this.val;
				} else if (this.L &gt; upper || this.R &lt; lower) {
					// access outer class GenericSegmentTree
					return defaultProvider.getDefault();
				} else {
					// access outer class GenericSegmentTree
					return combiner.combine(this.left.getRange(lower, upper), this.rite.getRange(lower, upper));
				}
			}
		}
	}
}
</PRE>

</BODY>
</HTML>
