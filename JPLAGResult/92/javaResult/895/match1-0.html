<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>81_wannacry89.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>81_wannacry89.java</CENTER></H3><HR>
<PRE>
import java.util.*;

class Solution {

    char[][] grid;
    int nrow, ncol;
<A NAME="0"></A>    int K;
    int startRow, startCol;

    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1-1.html#0',3,'match1-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>class State {
        int row, col;
        int cost;
        boolean[] keysInPossession;
        State(int row, int col, int cost</B></FONT>) {
            this.row=row; this.col=col; this.cost=cost;
            this.keysInPossession = new boolean[K];
        }
        @Override public boolean equals(Object obj) {
            State that = (State)obj;
            if (this.row != that.row || this.col != that.col) { return false; }
            for (int k = 0; k &lt; K; k++) {
                if (this.keysInPossession[k] != that.keysInPossession[k]) { return false; }
            }
            return true;
        }
        @Override public int hashCode() {
            int ret = 17;
            ret = 31*ret + row;
            ret = 31*ret + col;
            for (int k = 0; k &lt; K; k++) {
                ret = 31*ret  + (keysInPossession[k] ? 1 : 0);
            }
            return ret;
        }
    }

    public int shortestPathAllKeys(String[] g) {

        makeGrid(g);
        Set&lt;State&gt; visited = new HashSet&lt;State&gt;();
        Queue&lt;State&gt; que = new ArrayDeque&lt;State&gt;();
        State start = starting();
        visited.add(start);
        que.add(start);

        final int[] drow = new int[]{-1, +1, 0, 0};  // up, down, left, right
        final int[] dcol = new int[]{ 0, 0, -1, +1};
        while(!que.isEmpty()) {

            State on = que.remove();

            for (int ddir = 0; ddir &lt; 4; ddir++) {
                int row2 = on.row + drow[ddir];
                int col2 = on.col + dcol[ddir];

                // elimination criteria. Can't walk to row2,col2.
                if (!(row2 &gt;= 0 &amp;&amp; row2 &lt; nrow &amp;&amp; col2 &gt;= 0 &amp;&amp; col2 &lt; ncol &amp;&amp; grid[row2][col2] != '#')) {
                    continue;
                }

                // elimination critera. Don't have key where this is lock at row2,col2.
                char at2 = grid[row2][col2];
                if (at2 &gt;= 'A' &amp;&amp; at2 &lt;= 'F') {
                    int lockIdx = at2 - 'A';
                    if (!on.keysInPossession[lockIdx]) { // do not have lock we need
                        continue;
                    }
                }

                // Set up the state that we are moving to.
                State state2 = new State(row2, col2, on.cost+1);
                for (int k = 0; k &lt; K; k++) { state2.keysInPossession[k] = on.keysInPossession[k]; }
                // Are we picking up a key now?
                if (at2 &gt;= 'a' &amp;&amp; at2 &lt;= 'f') {
                    int keyIdx = at2 - 'a';
                    state2.keysInPossession[keyIdx] = true;
<A NAME="1"></A>                }

                // Did we hit the target?
                if (hitTarget(state2)) <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match1-1.html#1',3,'match1-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{ return state2.cost; }

                if (!visited.contains(state2)) {
                    visited.add(state2);
                    que.add(state2);
                }
            }</B></FONT>

        }
        return -1;

    }

    private boolean hitTarget(State on) {
        int total = 0;
        for (int k = 0; k &lt; K; k++) { if (on.keysInPossession[k]) { total++; } }
        return total == K;
    }

    private State starting() {
        State start = new State(startRow, startCol, 0);
        for (int k = 0; k &lt; K; k++) {
            start.keysInPossession[k] = false;
        }
        return start;
    }

    private void makeGrid(String[] g) {
        nrow = g.length;
        ncol = g[0].length();
        grid = new char[nrow][ncol];
        K = 1;
        for (int row = 0; row &lt; nrow; row++) {
            String rowString = g[row];
            for (int col = 0; col &lt; ncol; col++) {
                char c = rowString.charAt(col);
                grid[row][col] = c;
                if (c == '@') {
                    startRow = row;
                    startCol = col;
                }
                else if (c &gt;= 'A' &amp;&amp; c &lt;= 'F') {
                    K = Math.max(K,  c - 'A' + 1);
                }
            }
        }
    }
}
</PRE>

</BODY>
</HTML>
