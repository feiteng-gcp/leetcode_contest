<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>2_user9026b.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>2_user9026b.cpp</CENTER></H3><HR>
<PRE>
class Solution {
public:
    
    int srcR;
    int srcC;
    int res = INT_MAX;
    vector&lt; vector&lt;int&gt; &gt; keys;
    vector&lt;string&gt; maze;
    
    int m;
    int n;
    
    int shortestPathAllKeys(vector&lt;string&gt;&amp; grid) {
<A NAME="0"></A>        
        m = grid.size();
        n = grid[0].size();
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match25-1.html#0',3,'match25-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        maze = grid;
        
        for (int r = 0; r &lt; m; ++r)
            for (int c = 0; c &lt; n; ++c)
            {
                if (grid[r][c] == '@')
                {
                    srcR = r;</B></FONT>
                    srcC = c;
                }
                else if (islower(grid[r][c]) != 0)
                {
                    keys.push_back( {int(grid[r][c]), r, c} );
                }
            }
        
        sort(keys.begin(), keys.end());
        
        do 
        {
            unordered_set&lt;int&gt; keySet;
            int totalSteps = 0;
            int startR     = srcR;
            int startC     = srcC;
            
            int curSteps = 0;
            for (int i = 0; i &lt; keys.size(); ++i)
            {
                curSteps = BFS(startR, startC, keySet, keys[i][1], keys[i][2]);
                if (curSteps == -1) break;
                              
                totalSteps += curSteps;
                if (totalSteps &gt; res) break;
                keySet.insert( keys[i][0] );                
                
                startR = keys[i][1];
                startC = keys[i][2];
            }
            
            if (curSteps != -1)
            {
                res = min(res, totalSteps);
            }            
        }
        while (next_permutation(keys.begin(), keys.end()) == true);
        
        if (res == INT_MAX) return -1;
        else return res;
    }
    
    int BFS(int startR, int startC, unordered_set&lt;int&gt;&amp; keySet, int endR, int endC)
    {
        vector&lt; vector&lt;int&gt; &gt; visited(m, vector&lt;int&gt;(n, -1));
<A NAME="1"></A>        
        deque&lt; vector&lt;int&gt; &gt; Q;
        Q.push_back( {startR, startC} );
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match25-1.html#1',3,'match25-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        visited[startR][startC] = 0;
        
        int dr[] = {-1, 0, 1, 0};
        int dc[] = {0, 1, 0, -1};
        
        while (Q.size() &gt; 0)
        {
            vector&lt;int&gt; cur = Q.front();</B></FONT>
            Q.pop_front();
            
            for (int a = 0; a &lt; 4; ++a)
            {
                int newR = cur[0] + dr[a];
                int newC = cur[1] + dc[a];
                
                if (newR &lt; 0 || newC &lt; 0 || newR &gt;= m || newC &gt;= n) continue;
                if (visited[newR][newC] != -1) continue;
                if (maze[newR][newC] == '#') continue;
                if (isupper(maze[newR][newC]) != 0)
                {
                    int ascii = int(maze[newR][newC]) + 32;
                    if (keySet.count(ascii) == 0) continue;
                }
                
                Q.push_back( {newR, newC} );
                visited[newR][newC] = visited[cur[0]][cur[1]] + 1;
                
                if (newR == endR &amp;&amp; newC == endC) return visited[newR][newC];
            }
        }
        
        
        return -1;
    }
};
</PRE>
</BODY>
</HTML>
