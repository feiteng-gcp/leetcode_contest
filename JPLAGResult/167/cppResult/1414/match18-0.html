<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>84_lucifer1004.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>84_lucifer1004.cpp</CENTER></H3><HR>
<PRE>
struct Node{
    int x, y, k, step;
<A NAME="0"></A>};

const int dx[4] = {-1, 0, 1, 0};
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match18-1.html#0',3,'match18-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>const int dy[4] = {0, -1, 0, 1};

class Solution {
public:
    int shortestPath(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {
        queue&lt;Node&gt; bfs;
        int m = grid.size();
        int n = grid[0].size();</B></FONT>
        vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; visited(m, vector&lt;vector&lt;bool&gt;&gt;(n, vector&lt;bool&gt;(k+1)));
        bfs.push(Node{0, 0, 0, 0});
        while (!bfs.empty()) {
            Node front = bfs.front();
            bfs.pop();
<A NAME="1"></A>            int x = front.x;
            int y = front.y;
            int kk = front.k;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match18-1.html#1',3,'match18-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>            int step = front.step;
            
            // cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; kk &lt;&lt; &quot; &quot; &lt;&lt; step &lt;&lt; endl;
            
            if (x == n - 1 &amp;&amp; y == m - 1)
                return front.step;
            
            for (int i = 0; i &lt; 4; ++i) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m) continue;</B></FONT>
                int nk = kk + (grid[ny][nx] == 1);
                if (nk &gt; k) continue;
                if (visited[ny][nx][nk]) continue;
                // cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot; &quot; &lt;&lt; nk &lt;&lt; endl;
                visited[ny][nx][nk] = true;
                bfs.push(Node{nx, ny, nk, step+1});
            }
        }
        return -1;
    }
};
</PRE>
</BODY>
</HTML>
