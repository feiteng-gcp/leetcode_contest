<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>50_DenisGubar.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>50_DenisGubar.cpp</CENTER></H3><HR>
<PRE>
struct UnionFind
{
	vector&lt;int&gt; id;
	vector&lt;int&gt; sz;

	UnionFind(int N) : id(vector&lt;int&gt;(N)), sz(vector&lt;int&gt;(N, 1))
	{
		for (int i = 0; i &lt; N; ++i)
			id[i] = i;
	}
	int root(int i)
	{
		while (i != id[i])
		{
			id[i] = id[id[i]];
			i = id[i];
		}
		return i;
<A NAME="0"></A>	}
	bool find(int p, int q)
	{
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match12-1.html#0',3,'match12-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		return root(p) == root(q);
	}
	void unite(int p, int q)
	{
		int i = root(p);
		int j = root(q);
		if (sz[i] &lt; sz[j])
		{
			id[i] = j; sz[j] += sz[i];
		}</B></FONT>
		else
		{
			id[j] = i; sz[i] += sz[j];
		}
	}
};

class Solution {
public:
	int largestComponentSize(vector&lt;int&gt;&amp; A) {
		int N = A.size();
		UnionFind unionFind(N);
		vector&lt;char&gt; isPrime(100001, 1);
		isPrime[1] = isPrime[0] = 0;
		for (int i = 2; i * i &lt; 100001; ++i)
			if (isPrime[i])
				for (int k = i * i; k &lt; 100001; k += i)
					isPrime[k] = 0;
		vector&lt;int&gt; primes;
		for (int i = 2; i &lt; 100001; ++i)
<A NAME="1"></A>			if (isPrime[i])
				primes.push_back(i);
		vector&lt;vector&lt;int&gt;&gt; M(10000);
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match12-1.html#1',3,'match12-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>		for (int i = 0; i &lt; N; ++i)
		{
			int a = A[i];
			for (int p = 0; a &gt; 1; ++p)
			{</B></FONT>
				if (a % primes[p] == 0)
				{
					M[p].push_back(i);
					do
					{
						a /= primes[p];
					} while (a % primes[p] == 0);
				}
			}
		}
		for (int i = 0; i &lt; 10000; ++i)
			if (M[i].size() &gt; 1)
				for (int j = 1; j &lt; M[i].size(); ++j)
					if (!unionFind.find(M[i][0], M[i][j]))
						unionFind.unite(M[i][0], M[i][j]);
		return *max_element(unionFind.sz.begin(), unionFind.sz.end());
	}
};
</PRE>
</BODY>
</HTML>
