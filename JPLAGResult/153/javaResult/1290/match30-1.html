<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>150_hahahiehie.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>150_hahahiehie.java</CENTER></H3><HR>
<PRE>
import java.text.SimpleDateFormat;
import java.util.*;

class Utils {
    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low &lt; high) {
            int mid = low + (high - low) / 2;
            if (a[mid] &lt; target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low &lt; high) {
            int mid = low + (high - low) / 2;
            if (a[mid] &lt;= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static &lt;T extends Comparable&lt;T&gt;&gt; int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low &lt; high) {
            int mid = low + (high - low) / 2;
            if (a[mid].compareTo(target) &lt; 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static &lt;T extends Comparable&lt;T&gt;&gt; int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low &lt; high) {
            int mid = low + (high - low) / 2;
            if (a[mid].compareTo(target) &lt;= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x &lt;&lt; 32) | ((long) y &lt;&lt; 32 &gt;&gt;&gt; 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K &lt;= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) &gt;&gt; 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i &lt; j) {
            while (i &lt; j &amp;&amp; nums[i] &lt; pivot) i++;
            if (i &lt; j) nums[j--] = nums[i];

            while (i &lt; j &amp;&amp; pivot &lt; nums[j]) j--;
            if (i &lt; j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i &lt;= r; i++) {
            if (nums[i] &lt; pivot) {
                swap(nums, l++, i);
            } else if (nums[i] &gt; pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i &lt; j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n &lt;= 1) return false;
        int i = n - 1;
        while (i - 1 &gt;= 0 &amp;&amp; nums[i - 1] &gt;= nums[i]) {
            i--;
        }
        if (i &lt;= 0) return false;
        for (int j = n - 1; j &gt;= i; j--) {
            if (nums[j] &gt; nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 13;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i &lt; k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 &lt;&lt; 32) | ((long) h2 &lt;&lt; 32 &gt;&gt;&gt; 32);

        for (int i = k; i &lt; s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 &lt;&lt; 32) | ((long) h2 &lt;&lt; 32 &gt;&gt;&gt; 32);
        }

        return ans;
    }

    public static long stringHash(String s) {
        int h1 = 0;
        int h2 = 0;
        int seed1 = 13;
        int seed2 = 131;

        for (int i = 0; i &lt; s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);
        }
        return ((long) h1 &lt;&lt; 32) | ((long) h2 &lt;&lt; 32 &gt;&gt;&gt; 32);
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i &lt; n; i++) {
            int k = next[i - 1];
            while (k &gt; 0 &amp;&amp; s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i &lt; n; i++) {
            while (j &gt; 0 &amp;&amp; p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    // a, b could be negative
    // remainder &gt;= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r &lt; 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List&lt;Integer&gt; negativeBase(int n, int base) {
        List&lt;Integer&gt; digits = new ArrayList&lt;&gt;();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // Tested by leetcode 1163
    public static int[] suffixSort(int[] s) {
        int n = s.length;
        int[] count = new int[n], t;
        int[] SA = new int[n], nSA = new int[n];
        int[] rank = new int[n], nRank = new int[n];

        Integer[] tempArray = new Integer[n];
        for (int x = 0; x &lt; n; x++) tempArray[x] = x;
        Arrays.sort(tempArray, (a, b) -&gt; s[a] - s[b]); // NOTE: comparison might overflow!!!
        for (int x = 0; x &lt; n; x++) SA[x] = tempArray[x];

        int i, k;
        for (rank[SA[0]] = 0, i = 1; i &lt; n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k &lt; n &amp;&amp; rank[SA[n - 1]] &lt; n - 1; k &lt;&lt;= 1) {
            for (i = 0; i &lt; n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i &gt;= 0; i--) if (SA[i] &gt;= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i &lt; n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i &lt; n; i++) {
                nRank[SA[i]] = (SA[i] + k &gt;= n ||
                        SA[i - 1] + k &gt;= n ||
                        rank[SA[i]] != rank[SA[i - 1]] ||
                        rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
        return SA;
    }
}

class Fraction {
    long n, d;

    public Fraction(long n, long d) {
        long g = gcd(n, d);
        this.n = n / g;
        this.d = d / g;
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(numerator, denominator);
        this.n = numerator / g;
        this.d = denominator / g;
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    private int[] parent;
    private int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i &lt; n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        return parent[x] == x ? x : (parent[x] = find(parent[x]));
    }

    public void union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return;
        parent[py] = px;
        sz[px] += sz[py];
    }

    public int size(int x) {
        return sz[find(x)];
    }
}

class Trie {
    private static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
    }

    private TrieNode root = new TrieNode();

    public void insert(String word) {
        TrieNode cur = root;
        for (int i = 0; i &lt; word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) {
                cur.next[c] = new TrieNode();
            }
            cur = cur.next[c];
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i &lt; word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) return false;
            cur = cur.next[c];
            if (cur.isWord) return true;
        }
        return false;
    }
}

class Pair {
    long x, y;

    public Pair(long x, long y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object obj) {
        Pair pt = (Pair) obj;
        return (x == pt.x) &amp;&amp; (y == pt.y);
    }

    @Override
    public int hashCode() {
        //return (int) (x ^ (y * 31));
        long bits = x ^ (y * 31);
        return (((int) bits) ^ ((int) (bits &gt;&gt; 32)));
    }
}

class SegmentTree {
    private static class Node {
        int l, r, sum;
    }

    private Node[] nodes;

    public SegmentTree(int[] nums) {
        nodes = new Node[nums.length * 4];
        build(0, 0, nums.length - 1, nums);
    }

    private void build(int x, int l, int r, int[] nums) {
        nodes[x] = new Node();
        nodes[x].l = l;
        nodes[x].r = r;
        if (l == r) {
            nodes[x].sum = nums[l];
            return;
        }

        int m = (l + r) / 2;
        build(x * 2 + 1, l, m, nums);
        build(x * 2 + 2, m + 1, r, nums);
        nodes[x].sum = nodes[x * 2 + 1].sum + nodes[x * 2 + 2].sum;
    }

    public void update(int pos, int value) {
        update(0, pos, value);
    }

    private void update(int x, int pos, int value) {
        if (nodes[x].l == nodes[x].r) {
            nodes[x].sum = value;
            return;
        }
        int m = (nodes[x].l + nodes[x].r) / 2;
        if (pos &lt;= m) update(x * 2 + 1, pos, value);
        else update(x * 2 + 2, pos, value);
        nodes[x].sum = nodes[x * 2 + 1].sum + nodes[x * 2 + 2].sum;
    }

    public int getSum(int l, int r) {
        return getSum(0, l, r);
    }

    private int getSum(int x, int l, int r) {
        if (nodes[x].l == l &amp;&amp; nodes[x].r == r) {
            return nodes[x].sum;
        }

        int m = (nodes[x].l + nodes[x].r) / 2;
        if (r &lt;= m) return getSum(x * 2 + 1, l, r);
        else if (m + 1 &lt;= l) return getSum(x * 2 + 2, l, r);
        else return getSum(x * 2 + 1, l, m) + getSum(x * 2 + 2, m + 1, r);
    }
}

class BinaryIndexTree {
    private int[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 .. n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new int[n + 1];
    }

    // Add value to positoin k;
    public void add(int k, int value) {
        while (k &lt;= n) {
            c[k] += value;
            k += (k &amp; (k ^ (k - 1)));
        }
    }

    public int getSum(int k) {
        int sum = 0;
        while (k &gt; 0) {
            sum += c[k];
            k -= (k &amp; (k ^ (k - 1)));
        }
        return sum;
    }
}

abstract class Calculator&lt;T&gt; {
    abstract protected T parseNumber(String s);

    abstract protected T add(T a, T b);

    abstract protected T minus(T a, T b);

    abstract protected T multiply(T a, T b);

    abstract protected T divide(T a, T b);


    public T calculate(String s, T defaultValue) {
        if (s == null) {
            return defaultValue;
        }
        s = s.replaceAll(&quot;\\s+&quot;, &quot;&quot;);
        if (s.length() == 0) {
            return defaultValue;
        }
        pos = 0;
        return parse(s, defaultValue);
    }

    private int pos;

    private T parse(String s, T defaultValue) {
        Stack&lt;T&gt; st = new Stack&lt;&gt;();
        T cur = defaultValue;
        char sigh = '+';

        while (pos &lt; s.length()) {
            if (s.charAt(pos) == '(') {
                // skip the '('
                pos++;
                cur = parse(s, defaultValue);
                // skip the ')'
                pos++;
            } else {
                StringBuilder number = new StringBuilder();
                while (pos &lt; s.length()) {
                    char ch = s.charAt(pos);
                    if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '(' || ch == ')') {
                        break;
                    }
                    pos++;
                    number.append(ch);
                }
                cur = parseNumber(number.toString());
<A NAME="0"></A>            }
            if (sigh == '+') st.push(cur);
            if (sigh == '-') st.push(minus(defaultValue, cur));
            <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match30-0.html#0',2,'match30-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>if (sigh == '*') st.push(multiply(st.pop(), cur));
            if (sigh == '/') st.push(divide(st.pop(), cur));</B></FONT>

            if (pos &gt;= s.length() || s.charAt(pos) == ')') break;
            sigh = s.charAt(pos++);
        }
        T ans = defaultValue;
        while (!st.empty()) {
            ans = add(ans, st.pop());
        }
        return ans;
    }
}


public class Solution {





    public int makeArrayIncreasing(int[] arr1, int[] arr2) {
        int n = arr1.length;

        Arrays.sort(arr2);
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; arr2.length; i++) {
            if (i == 0) list.add(arr2[i]);
            else if (arr2[i] != arr2[i - 1]) {
                list.add(arr2[i]);
            }
        }
        int m = list.size();
        int[] t = new int[m];
        for (int i = 0; i &lt; m; i++) {
            t[i] = list.get(i);
        }

//
       // System.out.println(&quot;t = &quot; + Arrays.toString(t));

        int[][][] dp = new int[n + 1][m + 1][2];

        for (int i = 0; i &lt; n + 1; i++) {
            for (int j = 0; j &lt; m + 1; j++) {
                dp[i][j][0] = dp[i][j][1] = -1;
            }
        }


        dp[0][0][0] = 0;
        dp[0][0][1] = 1;

        int inf = 1 &lt;&lt; 28;
        int ans = inf;


        for (int j = 0; j &lt; m; j++) {
            dp[0][j][0] = 0;
            dp[0][j][1] = 1;
        }
        for (int i = 1; i &lt; n; i++) {
            for (int j = 0; j &lt; m; j++) {
                //dp[i][j][0];

                int tmp = inf;
                if (arr1[i - 1] &lt; arr1[i] &amp;&amp; dp[i - 1][j][0] &gt;= 0) {
                    tmp = dp[i - 1][j][0];
                }

                int k = Utils.lowerBound(t, arr1[i], j + 1);

                if (k - 1 &gt;= 0 &amp;&amp; dp[i - 1][k - 1][1] &gt;= 0) {
                    tmp = Math.min(tmp, dp[i - 1][k - 1][1]);
                }


                if (tmp &lt; inf) {
                    dp[i][j][0] = tmp;
                }

                // dp[i][j][1];

                tmp = inf;

                if (arr1[i - 1] &lt; t[j] &amp;&amp; dp[i - 1][j][0] &gt;= 0) {
                    tmp = dp[i - 1][j][0] + 1;
                }

                if (j - 1 &gt;= 0 &amp;&amp; dp[i - 1][j - 1][1] &gt;= 0) {
                    tmp = Math.min(tmp, dp[i - 1][j - 1][1] + 1);
                }


                if (tmp &lt; inf) {
                    dp[i][j][1] = tmp;
                }



              //  System.out.format(&quot;dp[%d][%d][%d] = %d\n&quot;, i, j, 0, dp[i][j][0]);
                //System.out.format(&quot;dp[%d][%d][%d] = %d\n\n&quot;, i, j, 1, dp[i][j][1]);

            }
        }

        for (int j = 0; j &lt; m; j++) {
            if (dp[n - 1][j][0] &gt;= 0) {
                ans = Math.min(ans, dp[n - 1][j][0]);
            }

            if (dp[n - 1][j][1] &gt;= 0) {
                ans = Math.min(ans, dp[n - 1][j][1]);
            }
        }

        if (ans &gt;= inf) return -1;
        else return ans;


    }


    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */


        /*
        10
10
4
5

42



68
86
63
1474

3178
        */

//        int width = 68, height = 86, sideLength = 63, maxOnes = 1474;
//        String[] words = {&quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;, &quot;ability&quot;, &quot;actt&quot;, &quot;actor&quot;, &quot;access&quot;};
//        String[] puzzles = {&quot;aboveyz&quot;, &quot;abrodyz&quot;, &quot;abslute&quot;, &quot;absoryz&quot;, &quot;actresz&quot;, &quot;gaswxyz&quot;};
//        //System.out.println(new Solution().maximumNumberOfOnes(width, height, sideLength, maxOnes));

        int[] arr1 = {5,16,19,2,1,12,7,14,5,16}, arr2 = {6,17,4,3,6,13,4,3,18,17,16,7,14,1,16};

        //int[] arr1 = {1,5,3,6,7}, arr2 = {4,3,1};

        System.out.println(new Solution().makeArrayIncreasing(arr1, arr2));

        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + &quot;ms&quot;);
    }
}
</PRE>

</BODY>
</HTML>
