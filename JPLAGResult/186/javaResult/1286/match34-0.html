<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>370_yuruiyin.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>370_yuruiyin.java</CENTER></H3><HR>
<PRE>
import java.util.*;

public class TreeMultiSet&lt;E&gt; extends AbstractSet&lt;E&gt;
        implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable {

    private static final long serialVersionUID = 1L;

    private transient NavigableMap&lt;E, Integer&gt; treeMap;

    // 总个数(重复算多个)
    private transient int size = 0;

    private TreeMultiSet(NavigableMap&lt;E, Integer&gt; m) {
        this.treeMap = m;
    }

    public TreeMultiSet() {
        this(new TreeMap&lt;E, Integer&gt;());
    }

    public TreeMultiSet(Comparator&lt;? super E&gt; comparator) {
        this(new TreeMap&lt;&gt;(comparator));
    }

    public TreeMultiSet(Collection&lt;? extends E&gt; c) {
        this();
        addAll(c);
    }

    public TreeMultiSet(SortedSet&lt;E&gt; s) {
        this(s.comparator());
        addAll(s);
    }

    /**
     * 可重复元素的迭代器
     */
    private class Itr implements Iterator&lt;E&gt; {
        private int cursor;
        // 当前treeMap的key对应的
        private Iterator&lt;E&gt; curKeyItr;
        // 当前元素
        private E curVal;
        // 当前treeMap的key对应的索引，即对应当前第几个重复元素
        private int curKeyItrIndex;

        Itr(NavigableSet&lt;E&gt; keySet) {
            cursor = 0;
            curKeyItr = keySet.iterator();
            if (curKeyItr.hasNext()) {
                curVal = curKeyItr.next();
            }
            curKeyItrIndex = 0;
        }

        Itr() {
            this(treeMap.navigableKeySet());
        }

        @Override
        public boolean hasNext() {
            return cursor &lt; size;
        }

        @Override
        public E next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }

            int curValCount = treeMap.get(curVal);
            E res = null;
            if (curKeyItrIndex &lt; curValCount) {
                curKeyItrIndex++;
                res = curVal;
                if (curKeyItrIndex == curValCount) {
                    // 移动到下一个key
                    if (curKeyItr.hasNext()) {
                        curVal = curKeyItr.next();
                    }
                    curKeyItrIndex = 0;
                }
            }

            cursor++;
            return res;
        }
    }

    /**
     * 返回所有不相同的元素的正向迭代器
     * @return 所有不相同的元素的正向迭代器
     */
    public Iterator&lt;E&gt; diffIterator() {
        return treeMap.navigableKeySet().iterator();
    }

    /**
     * 返回所有不相同的元素的反向迭代器
     * @return 所有不相同的元素的反向迭代器
     */
    public Iterator&lt;E&gt; diffDescendingIterator() {
        return treeMap.descendingKeySet().iterator();
    }

    /**
     * 返回所有元素（重复元素要next多次）的正向迭代器
     * @return 所有元素的正向正向迭代器
     */
    @Override
    public Iterator&lt;E&gt; iterator() {
        return new Itr();
    }

    /**
     * 返回所有元素（重复元素要next多次）的反向迭代器
     * @return 所有元素的反向迭代器
     */
    @Override
    public Iterator&lt;E&gt; descendingIterator() {
        return new Itr(treeMap.descendingKeySet());
    }

    /**
     * 返回逆序集合
     * @return 逆序集合
     */
    @Override
    public NavigableSet&lt;E&gt; descendingSet() {
        TreeMultiSet&lt;E&gt; descendingSet = new TreeMultiSet&lt;&gt;(treeMap.descendingMap());
        descendingSet.size = size;
        return descendingSet;
    }

    /**
     * 计算map中的所有元素个数之和（并不是key的个数，而是sum(key * value)）
     * @param countMap key为元素，value为count的map
     * @return map的所有元素个数之和
     */
    private int calcMapSize(NavigableMap&lt;E, Integer&gt; countMap) {
        int size = 0;
        for (E e : countMap.keySet()) {
            size += countMap.get(e);
        }
        return size;
    }

    /**
     * 返回指定头尾元素的连续子集
     */
    @Override
    public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) {
        NavigableMap&lt;E, Integer&gt; subMap = treeMap.subMap(fromElement, fromInclusive, toElement, toInclusive);
        TreeMultiSet&lt;E&gt; subSet = new TreeMultiSet&lt;&gt;(subMap);
        subSet.size = calcMapSize(subMap);
        return subSet;
    }

    /**
     * 返回头部连续子集
     */
    @Override
    public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
        NavigableMap&lt;E, Integer&gt; headMap = treeMap.headMap(toElement, inclusive);
        TreeMultiSet&lt;E&gt; headSet = new TreeMultiSet&lt;&gt;(headMap);
        headSet.size = calcMapSize(headMap);
        return headSet;
    }

    /**
     * 返回尾部连续子集
     */
    @Override
    public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
        NavigableMap&lt;E, Integer&gt; tailMap = treeMap.tailMap(fromElement, inclusive);
        TreeMultiSet&lt;E&gt; tailSet = new TreeMultiSet&lt;&gt;(tailMap);
        tailSet.size = calcMapSize(tailMap);
        return tailSet;
    }

    @Override
    public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
        return subSet(fromElement, true, toElement, false);
    }

    @Override
    public SortedSet&lt;E&gt; headSet(E toElement) {
        return headSet(toElement, false);
    }

    @Override
    public SortedSet&lt;E&gt; tailSet(E fromElement) {
        return tailSet(fromElement, true);
    }

    @Override
    public Comparator&lt;? super E&gt; comparator() {
        return treeMap.comparator();
    }

    /**
     * 返回总的元素个数（重复算多个）
     * @return 总的元素个数
     */
    public int size() {
        return size;
    }

    /**
     * 返回不同的元素个数。
     * @return 不同的元素个数
     */
    public int diffElementSize() {
        // 也就是treeMap的key的个数
        return treeMap.keySet().size();
    }

    /**
     * 获取第一个元素（如果比较器是从小到大的，第一个元素就是最小的，否则就是最大的）
     * @return 第一个元素
     */
    public E first() {
        if (treeMap.isEmpty()) {
            return null;
        }

        return treeMap.firstKey();
    }

    /**
     * 获取最后一个元素（如果比较器是从小到大的，第一个元素就是最大的，否则就是最小的）
     * @return 最后一个元素
     */
    public E last() {
        if (treeMap.isEmpty()) {
            return null;
        }
        return treeMap.lastKey();
    }

    /**
     * 是否包含某个元素
     * @param o 指定元素
     * @return true-包含，false-不包含
     */
    @Override
    public boolean contains(Object o) {
        return treeMap.containsKey(o);
    }

    @Override
    public void clear() {
        treeMap.clear();
        size = 0;
    }

    /**
     * 添加指定元素(1个)
     * @param e 要添加的元素
     * @return true
     */
    @Override
    public boolean add(E e) {
        return add(e, 1);
    }

    /**
     * 添加指定个数的元素，如果当前元素已经存在，则当前元素的数量+count，否则新建一个key。
     * @param e 要添加的元素
     * @param count 要添加的指定元素的个数
     */
    public boolean add(E e, int count) {
        if (treeMap.containsKey(e)) {
            treeMap.put(e, treeMap.get(e) + count);
        } else {
            treeMap.put(e, count);
        }
        size += count;
        return true;
    }

    /**
     * 设置指定元素的数量
     * @param e 指定元素
     * @param count 数量
     */
    public void setCount(E e, int count) {
        int oldCount = treeMap.getOrDefault(e, 0);
        treeMap.put(e, count);
        size = size - oldCount + count;
    }

    /**
     * 获取指定元素的个数
     * @param e 指定元素
     * @return 指定元素的个数
     */
    public int count(E e) {
        return treeMap.getOrDefault(e, 0);
    }

    /**
     * 注意：一定要复写这个方法，目的是覆盖父类Collection的remove操作(复杂度是O(n))
     * 删除1个指定元素
     * @param e 要删除的元素
     * @return 是否删除成功，若删除的元素不存在，返回false, 若删除的元素存在，但是要删除的count大于存在的count，返回false。否则返回true
     */
    public boolean remove(Object e) {
        return remove((E) e, 1);
    }

    /**
     * 删除count个指定元素，比如集合为[2,3,3,3,2], 若调用removeCount(3,2)，也就是删除2两个2，那么集合就变成[2,3,2]
     * @param e 要删除的元素
     * @param count 要删除的指定元素的个数
     * @return 是否删除成功，若删除的元素不存在，返回false, 若删除的元素存在，但是要删除的count大于存在的count，返回false。否则返回true
     */
    public boolean remove(E e, int count) {
        if (count &lt;= 0) {
            return false;
        }

        if (!treeMap.containsKey(e)) {
            return false;
        }

        int curCount = treeMap.get(e);
        if (curCount &lt; count) {
            return false;
        } else if (curCount == count) {
            treeMap.remove(e);
        } else {
            treeMap.put(e, curCount - count);
        }

        size -= count;
        return true;
    }

    /**
     * 删除指定元素（包括所有的指定元素）。比如集合为[2,3,3,3,2]，若调用removeKey(3)，那么会删除所有的3，则集合变成[2,2]
     * @param e 要删除的元素
     * @return 是否删除成功，若删除的元素不存在，返回false，否则返回true
     */
    public boolean removeAll(Object e) {
        if (!treeMap.containsKey(e)) {
            return false;
        }

        size -= treeMap.get(e);
        treeMap.remove(e);
        return true;
    }

    /**
     * 返回比给定元素严格小的最大元素
     * @param e 给定元素
     * @return 比给定元素严格小的最大元素，若不存在，则返回null
     */
    @Override
    public E lower(E e) {
        return treeMap.lowerKey(e);
    }

    /**
     * 返回小于或等于给定元素的最大元素
     * @param e 给定元素
     * @return 小于或等于给定元素的最大元素，若不存在，则返回null
     */
    @Override
    public E floor(E e) {
        return treeMap.floorKey(e);
    }

    /**
     * 返回比给定元素严格大的最小元素
     * @param e 给定元素
     * @return 比给定元素严格小的最大元素，若不存在，则返回null
     */
    @Override
    public E higher(E e) {
        return treeMap.higherKey(e);
    }

    /**
     * 返回大于或等于给定元素的最小元素
     * @param e 给定元素
     * @return 大于或等于给定元素的最小元素，若不存在，则返回null
     */
    @Override
    public E ceiling(E e) {
        return treeMap.ceilingKey(e);
    }

    /**
     * 删除第一个元素（指定数量）
     * @param count 指定数量
     * @return 第一个元素
     */
    public E pollFirst(int count) {
        if (treeMap.isEmpty()) {
            return null;
        }
        E firstKey = treeMap.firstKey();
        remove(firstKey, count);
        return firstKey;
    }

    /**
     * 删除第一个元素(第一个元素有多个重复，仅删除其中一个)
     * @return 第一个元素
     */
    public E pollFirst() {
        return pollFirst(1);
    }

    /**
     * 删除第一个元素(包括所有数量)
     * @return 第一个元素
     */
    public E pollFirstAll() {
        // firstKey如果不存在可能会抛异常
        if (treeMap.isEmpty()) {
            return null;
        }

        E firstKey = treeMap.firstKey();
        size -= treeMap.get(firstKey);
        treeMap.remove(firstKey);
        return firstKey;
    }

    /**
     * 删除最后一个元素（若最后一个元素有多个重复，仅删除其中一个）
     * @return 最后一个元素
     */
    public E pollLast() {
        return pollLast(1);
    }

    /**
     * 删除最后一个元素（指定数量）
     * @param count 指定数量
     * @return 最后一个元素
     */
    public E pollLast(int count) {
        if (treeMap.isEmpty()) {
            return null;
        }
        E lastKey = treeMap.lastKey();
        remove(lastKey, count);
        return lastKey;
    }

    /**
     * 删除最后一个元素(包括所有数量)
     * @return 最后一个元素
     */
    public E pollLastAll() {
        if (treeMap.isEmpty()) {
            return null;
        }
        E lastKey = treeMap.lastKey();
        size -= treeMap.get(lastKey);
        treeMap.remove(lastKey);
        return lastKey;
    }

    /**
     * 浅拷贝
     * @return 浅拷贝后的TreeMultiSet
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public Object clone() throws CloneNotSupportedException {
        TreeMultiSet&lt;E&gt; clone = (TreeMultiSet&lt;E&gt;) super.clone();
        clone.treeMap = new TreeMap&lt;&gt;(treeMap);
        return clone;
    }

}

class Solution {
 public int constrainedSubsetSum(int[] nums, int k) {
        // 优先队列
//        PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k, (o1, o2) -&gt; o2 - o1);
        TreeMultiSet&lt;Integer&gt; set = new TreeMultiSet&lt;&gt;();
        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        int len = nums.length;
        int[] dp = new int[len];

        dp[0] = nums[0];
//        heap.offer(dp[0]);
        set.add(dp[0]);
        queue.offer(dp[0]);
//        heap.offer(dp[0]);

        for (int i = 1; i &lt; len; i++) {
            int max = set.last();
            dp[i] = max &gt; 0 ? max + nums[i] : nums[i];
            queue.offer(dp[i]);
            set.add(dp[i]);
<A NAME="0"></A>            if (queue.size() &gt; k) {
                int removeNum = queue.peek();
                queue.poll();
                <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match34-1.html#0',3,'match34-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>set.remove(removeNum);
            }
        }

        int ansMax = Integer.MIN_VALUE;
        for (int i = 0; i &lt; len; i++) {
            ansMax = Math.max(ansMax, dp[i]);
        }

        return ansMax;
    }
}</B></FONT>
</PRE>

</BODY>
</HTML>
