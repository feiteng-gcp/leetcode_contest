<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>139_diogo149.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>139_diogo149.py</CENTER></H3><HR>
<PRE>
import collections

class Solution:
    def minPushBox(self, grid):
        # given a grid, the location of the box and player determine whether or not the player can move
        
        # find:
        # - which directions the box can move initially
        # - target location
<A NAME="0"></A>        # - box location
        # - player location
        n = len(grid)
        m = len<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match16-1.html#0',3,'match16-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>(grid[0])
        for i in range(n):
            for j in range(m):
                if grid[i][j] == &quot;S&quot;:
                    player_loc = (i, j)
                elif grid[i][j] == &quot;B&quot;:
                    box_loc = (i, j)
                elif grid[i][j] == &quot;T&quot;:
                    target_loc = (i, </B></FONT>j)
        
        def up(coord):
            return (coord[0] - 1, coord[1])
        
        def down(coord):
            return (coord[0] + 1, coord[1])
        
        def left(coord):
            return (coord[0], coord[1] - 1)

        def right(coord):
            return (coord[0], coord[1] + 1)
        
        directions = [up, down, left, right]
        inverse_directions = [down, up, right, left]
        
        def can_move(coord, box_loc):
            i, j = coord
            return 0 &lt;= i &lt; n and 0 &lt;= j &lt; m and grid[i][j] != &quot;#&quot; and coord != box_loc
        
        def player_reachable_directions(box_loc, player_loc):
            visited = {player_loc}
            location_stack = [player_loc]
            while location_stack:
                curr = location_stack.pop()
                for direction in directions:
                    tmp = direction(curr)
                    if tmp not in visited:
                        if can_move(tmp, box_loc):
                            visited.add(tmp)
                            location_stack.append(tmp)
            ans = []
            for dir_idx in range(4):
                if inverse_directions[dir_idx](box_loc) in visited:
                    ans.append(dir_idx)
            return ans
        
        def box_movable_directions(box_loc, player_loc):
            ans = []
            for dir_idx in player_reachable_directions(box_loc, player_loc):
                if can_move(directions[dir_idx](box_loc), box_loc):
                    ans.append(dir_idx)
            return ans
                    
        initial_directions = box_movable_directions(box_loc, player_loc)
        
        # BFS from initial location and directions
        queue = collections.deque()
        min_pushes = {
            (box_loc, 0): 0,
            (box_loc, 1): 0,
            (box_loc, 2): 0,
            (box_loc, 3): 0,
        }
        for dir_idx in initial_directions:
            key = (directions[dir_idx](box_loc), dir_idx)
            min_pushes[key] = 1
            queue.append(key)

        while queue:
            key = queue.popleft()
            # current box location and direction it moved from
            curr_loc, curr_dir_idx = key
            # print(curr_loc, curr_dir_idx)
            curr_player_loc = inverse_directions[curr_dir_idx](curr_loc)
            curr_pushes = min_pushes[key]
            
            for dir_idx in box_movable_directions(curr_loc, curr_player_loc):
                new_loc = directions[dir_idx](curr_loc)
                if new_loc == target_loc:
                    return curr_pushes + 1
                new_key = (new_loc, dir_idx)
                if new_key not in min_pushes:
                    min_pushes[new_key] = curr_pushes + 1
                    queue.append(new_key)

        # print(target_loc)
        # print(min_pushes)
        # print(down((2, 1)))
        # print(box_movable_directions((2, 1), down((2, 1))))
        return -1
</PRE>

</BODY>
</HTML>
