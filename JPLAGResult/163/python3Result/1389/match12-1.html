<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>103_sukeyzhou.py</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>103_sukeyzhou.py</CENTER></H3><HR>
<PRE>
<A NAME="0"></A><FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match12-0.html#0',2,'match12-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>class Solution:
    def minPushBox(self, grid: List[List[str]]) -&gt; int:
        R, C = len(grid), len(grid[0])
        for i in range(R):
            for j in range(C):
                if grid[i][j] == 'T':
                    T = (i, j)
                elif grid[i][j] == 'S':
                    S = (i, j)
                elif grid[i][j] == 'B':
                    B = (i, </B></FONT>j)
        
        def valid(S, B, target):
            if S == target: return True
            queue = collections.deque([S])
            seen = set([S])
            while queue:
                x, y = queue.popleft()
                for i, j in ((0,1),(0,-1),(1,0),(-1,0)):
                    if 0 &lt;= x+i &lt; R and 0 &lt;= y+j &lt; C and grid[x+i][y+j] != '#' and (x+i,y+j) != B and (x+i,y+j) not in seen:
                        if (x+i,y+j) == target: return True
                        queue.append((x+i, y+j))
                        seen.add((x+i,y+j))
            return False
        
        queue = collections.deque([(S, B)])
        seen = set([(S, B)])
        moves = 1
        while queue:
            for _ in range(len(queue)):
                S, B = queue.popleft()
                x, y = B
                if 0 &lt; x &lt; R-1 and grid[x-1][y] != '#' and grid[x+1][y] != '#':
                    up = valid(S, B, (x-1, y))
                    if up and (B, (x+1, y)) not in seen: 
                        if (x+1, y) == T: return moves
                        queue.append((B, (x+1, y)))
                        seen.add((B, (x+1, y)))
                    down = valid(S, B, (x+1, y))
                    if down and (B, (x-1, y)) not in seen:
                        if (x-1, y) == T: return moves
                        queue.append((B, (x-1, y)))
                        seen.add((B, (x-1, y)))       
                if 0 &lt; y &lt; C-1 and grid[x][y-1] != '#' and grid[x][y+1] != '#':
                    left = valid(S, B, (x, y-1))
                    if left and (B, (x, y+1)) not in seen: 
                        if (x, y+1) == T: return moves
                        queue.append((B, (x, y+1)))
                        seen.add((B, (x, y+1)))
                    right = valid(S, B, (x, y+1))
                    if right and (B, (x, y-1)) not in seen:
                        if (x, y-1) == T: return moves
                        queue.append((B, (x, y-1)))
                        seen.add((B, (x, y-1)))
            moves += 1
        return -1
</PRE>

</BODY>
</HTML>
