<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>125_n0rma.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>125_n0rma.cpp</CENTER></H3><HR>
<PRE>
using namespace std;
#ifdef _DEBUG
#define _GLIBCXX_DEBUG
#include &quot;dump.hpp&quot;
#else
#define dump(...)
#endif

//#define int long long
#define ll long long
#define DBG 1
#define rep(i, a, b) for (int i = (a); i &lt; (b); i++)
#define rrep(i, a, b) for (int i = (b)-1; i &gt;= (a); i--)
#define loop(n) rep(loop, (0), (n))
#define all(c) begin(c), end(c)
const int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;
const int MOD = (int)(1e9) + 7;
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
using pii = pair&lt;int, int&gt;;
// template&lt;class T&gt; ostream &amp;operator&lt;&lt;(ostream &amp;os,T &amp;t){dump(t);return os;}
template &lt;typename T, typename S&gt;istream &amp;operator&gt;&gt;(istream &amp;is, pair&lt;T, S&gt; &amp;p) { is &gt;&gt; p.first &gt;&gt; p.second; return is; }
//template &lt;typename T, typename S&gt;ostream &amp;operator&lt;&lt;(ostream &amp;os, pair&lt;T, S&gt; &amp;p) {os &lt;&lt; p.first &lt;&lt; &quot; &quot; &lt;&lt; p.second;return os;}

template &lt;typename T&gt; void printvv(const vector&lt;vector&lt;T&gt;&gt; &amp;v) {
	cerr &lt;&lt; endl;
	rep(i, 0, v.size()) rep(j, 0, v[i].size()) {
		if (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {
			cerr &lt;&lt; &quot;INF&quot;;
		}
		else
			cerr &lt;&lt; v[i][j];
		cerr &lt;&lt; (j == v[i].size() - 1 ? '\n' : ' ');
	}
	cerr &lt;&lt; endl;
}

#ifndef _DEBUG
#define printvv(...)
#endif
void YES(bool f) { cout &lt;&lt; (f ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl; }
void Yes(bool f) { cout &lt;&lt; (f ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; endl; }
template &lt;class T, class U&gt;bool chmin(T&amp; a, U b) { if (a &gt; b) { a = b; return true; }return false; }
template &lt;class T, class U&gt;bool chmax(T&amp; a, U b) { if (a &lt; b) { a = b; return true; }return false; }
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
<A NAME="0"></A> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match32-0.html#0',2,'match32-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>class FindElements {
public:
	set&lt;int&gt;s;
	void dfs(TreeNode* root, int val) {
		if (root == nullptr)return;
		root-&gt;val = val;
		s.emplace(val);
		dfs(root-&gt;left, val * 2 + 1);
		dfs(root-&gt;right, val * 2 + 2);
	}
	FindElements(TreeNode* root) {
		dfs(root, 0);
	}

	bool find(int target) {
		return s.count(target);
	}
};</B></FONT>

/**
 * Your FindElements object will be instantiated and called as such:
 * FindElements* obj = new FindElements(root);
 * bool param_1 = obj-&gt;find(target);
 */
</PRE>
</BODY>
</HTML>
