<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>183_zerotrac2.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>183_zerotrac2.cpp</CENTER></H3><HR>
<PRE>
using PII = pair&lt;int, int&gt;;

struct Dwell {
    int bx, by; //box
    int px, py; //person
    int d; // dist
    Dwell(int _bx, int _by, int _px, int _py, int _d): bx(_bx), by(_by), px(_px), py(_py), d(_d) {}
    void print() {cout &lt;&lt; bx &lt;&lt; &quot; &quot; &lt;&lt; by &lt;&lt; &quot; &quot; &lt;&lt; px &lt;&lt; &quot; &quot; &lt;&lt; py &lt;&lt; &quot; &quot; &lt;&lt; d &lt;&lt; endl;}
};
<A NAME="0"></A>
class Solution {
private:
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match18-0.html#0',2,'match18-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    static constexpr int dirs[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    
public:</B></FONT>
    bool bfs(const vector&lt;vector&lt;char&gt;&gt;&amp; grid, int bx, int by, int psx, int psy, int ptx, int pty) {
        //cout &lt;&lt; &quot;do bfs: &quot; &lt;&lt; bx &lt;&lt; &quot; &quot; &lt;&lt; by &lt;&lt; &quot; &quot; &lt;&lt; psx &lt;&lt; &quot; &quot; &lt;&lt; psy &lt;&lt; &quot; &quot; &lt;&lt; ptx &lt;&lt; &quot; &quot; &lt;&lt; pty &lt;&lt; &quot;\n&quot;;
        int m = grid.size();
        int n = grid[0].size();
        if (psx == ptx &amp;&amp; psy == pty) {
            return true;
        }
        if (ptx &lt; 0 || ptx &gt;= m || pty &lt; 0 || pty &gt;= n || grid[ptx][pty] == '#') {
            return false;
        }
        
        vector&lt;vector&lt;int&gt;&gt; g(m, vector&lt;int&gt;(n));
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == '#') {
                    g[i][j] = 1;
                }
                else {
                    g[i][j] = 0;
                }
            }
        }
        g[bx][by] = 1;
        
<A NAME="2"></A>        queue&lt;PII&gt; q;
        q.emplace(psx, psy);
        g[psx][psy] = 1;
<FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match18-0.html#2',2,'match18-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        while (!q.empty()) {
            auto [cx, cy] = q.front();
            //if (ptx == 1 &amp;&amp; pty == 5) cout &lt;&lt; &quot;cx, cy = &quot; &lt;&lt; cx &lt;&lt; &quot; &quot; &lt;&lt; cy &lt;&lt; &quot;\n&quot;;
            q.pop();
            for (int i = 0; i &lt; 4; ++i) {
                int nx = cx + dirs[i][0];
                int ny = cy + dirs[i][1];
                if (nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; g[nx][ny] == 0) {</B></FONT>
                    q.emplace(nx, ny);
                    g[nx][ny] = 1;
                    if (nx == ptx &amp;&amp; ny == pty) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    int minPushBox(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        int m = grid.size();
        int n = grid[0].size();
<A NAME="1"></A>        int dist[m][n][4];
        memset(dist, -1, sizeof(dist));
        
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match18-0.html#1',2,'match18-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        int s_bx, s_by; //start box
        int s_px, s_py; //start person
        int t_x, t_y; //target
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (grid[i][j] == 'B') {
                    s_bx = i;
                    s_by = j;
                }
                else if (grid[i][j] == 'S') {
                    s_px = i;
                    s_py = j;
                }</B></FONT>
                else if (grid[i][j] == 'T') {
                    t_x = i;
                    t_y = j;
                }
            }
        }
        
        queue&lt;Dwell&gt; q;
        q.emplace(s_bx, s_by, s_px, s_py, 0);
        while (!q.empty()) {
            Dwell cur = q.front();
            //cur.print();
            //cout &lt;&lt; &quot;grid = &quot; &lt;&lt; grid[cur.bx][cur.by] &lt;&lt; &quot;\n&quot;;
            q.pop();
            for (int i = 0; i &lt; 4; ++i) {
                // cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;
                int nx = cur.bx + dirs[i][0];
                int ny = cur.by + dirs[i][1];
                //cout &lt;&lt; &quot;nx, ny = &quot; &lt;&lt; nx &lt;&lt; &quot; &quot; &lt;&lt; ny &lt;&lt; &quot;\n&quot;;
                if (nx &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; grid[nx][ny] != '#' &amp;&amp; dist[nx][ny][i] == -1) {
                    //cout &lt;&lt; &quot;good\n&quot;;
                    bool check = bfs(grid, cur.bx, cur.by, cur.px, cur.py, cur.bx - dirs[i][0], cur.by - dirs[i][1]);
                    //cout &lt;&lt; &quot;check = &quot; &lt;&lt; check &lt;&lt; &quot;\n&quot;;
                    if (check) {
                        q.emplace(nx, ny, cur.bx, cur.by, cur.d + 1);
                        dist[nx][ny][i] = cur.d + 1;
                        if (nx == t_x &amp;&amp; ny == t_y) {
                            return cur.d + 1;
                        }
                    }
                }
            }
        }
        return -1;
    }
};
</PRE>
</BODY>
</HTML>
