<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>55_liang5.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>55_liang5.cpp</CENTER></H3><HR>
<PRE>
struct State {
    int bx, by, sx, sy;
<A NAME="0"></A>    int step;
    State(int bx_, int by_, int sx_, int sy_, int step_) : bx(bx_), by(by_), sx(sx_), sy(sy_), step(step_) {}
};
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match26-1.html#0',3,'match26-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>const int dir[][2] = {{-1,0},{1,0},{0,-1},{0,1}};</B></FONT>

class Solution {
public:
    int ans[21][21][21][21];
    int n, m;
    deque&lt;State&gt; q;
    
    int minPushBox(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        q.clear();
        n = grid.size();
<A NAME="1"></A>        m = grid[0].size();
        memset(ans, 0x3f, sizeof(ans));
        int sx, sy, bx, by, tx, ty;
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match26-1.html#1',3,'match26-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>        for (int i = 0 ; i &lt; n ; ++i)
            for (int j = 0 ; j &lt; m ; ++j)
                if (grid[i][j] == 'S') {sx = i; sy = j;}
                else if (grid[i][j] == 'B') {bx = i; by = j;}
                else if (grid[i][j] == 'T') {tx = i; ty = j;}
        int best = 1e9;</B></FONT>
        ans[bx][by][sx][sy] = 0;
        q.push_back(State(bx, by, sx, sy, 0));
        while (!q.empty()) {
            State st = q.front();
            q.pop_front();
            if (st.bx == tx &amp;&amp; st.by == ty) {
                best = min(best, st.step);
                continue;
            }
            for (int d = 0 ; d &lt; 4 ; ++d) {
                int tox = st.sx + dir[d][0];
                int toy = st.sy + dir[d][1];
                if (tox &lt; 0 || tox &gt;= n || toy &lt; 0 || toy &gt;= m) continue;
                if (grid[tox][toy] == '#') continue;
                if (tox == st.bx &amp;&amp; toy == st.by) { // push
                    int btox = tox + dir[d][0];
                    int btoy = toy + dir[d][1];
                    if (btox &lt; 0 || btox &gt;= n || btoy &lt; 0 || btoy &gt;= m) continue;
                    if (grid[btox][btoy] == '#') continue;
                    if (st.step + 1 &lt; ans[btox][btoy][tox][toy]) {
                        ans[btox][btoy][tox][toy] = st.step + 1;
                        q.push_back(State(btox, btoy, tox, toy, st.step+1));
                    }
                } else {
                    if (st.step &lt; ans[st.bx][st.by][tox][toy]) {
                        ans[st.bx][st.by][tox][toy] = st.step;
                        q.push_back(State(st.bx, st.by, tox, toy, st.step));
                    }
                }
            }
        }
        if (best == 1e9) return -1;
        return best;
    }
};
</PRE>
</BODY>
</HTML>
