<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>182_ysq.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>182_ysq.cpp</CENTER></H3><HR>
<PRE>

class Solution {
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {-1, 1, 0, 0};
    
    bool isValid (int x, int y, vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        return 0 &lt;= x &amp;&amp; x &lt; grid.size() &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; grid[0].size() &amp;&amp; grid[x][y] != '#';
    }
    
    set&lt;pair&lt;int, int&gt;&gt; visited;
    bool canReach(int t_x, int t_y, int b_x, int b_y, int s_x, int s_y, vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        // cout &lt;&lt; t_x &lt;&lt; &quot; &quot; &lt;&lt; t_y &lt;&lt; &quot; &quot; &lt;&lt; s_x &lt;&lt; &quot; &quot; &lt;&lt; s_y &lt;&lt; endl; 
        if (t_x == s_x &amp;&amp; t_y == s_y) {
            return true;
        }  
        for (int i = 0; i &lt; 4; i++) {
            int new_x = s_x + dx[i];
            int new_y = s_y + dy[i];
            if (isValid(new_x, new_y, grid) &amp;&amp; (new_x != b_x || new_y != b_y) &amp;&amp; visited.count(make_pair(new_x, new_y)) == 0) {
                visited.insert(make_pair(new_x, new_y));
                if (canReach(t_x, t_y, b_x, b_y, new_x, new_y, grid)) {
                    return true;
                }
            }
        }
        return false;
    }

public:
    int minPushBox(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
<A NAME="0"></A>        int box_x, box_y;
        int player_x, player_y;
        int target_x, target_y;
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match12-0.html#0',2,'match12-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        queue&lt;vector&lt;int&gt;&gt; qu;
        set&lt;vector&lt;int&gt;&gt; m_visited;
        for (int i = 0; i &lt; grid.size(); i++) {
            for (int j = 0; j &lt; grid[0].size(); j++) {
                if (grid[i][j] == 'B') {
                    box_x = i; box_y = j;
                }
                if (grid[i][j] == 'S') {
                    player_x = i; player_y = j;
                }
                if (grid[i][j] == 'T') {
                    target_x = i; target_y = j;
                }
            }
        }
        // cout &lt;&lt; player_x &lt;&lt; &quot; &quot; &lt;&lt; player_y &lt;&lt; endl;
        vector&lt;int&gt; temp = {box_x, box_y, player_x, player_y, 0};</B></FONT>
        qu.push(temp);
<A NAME="1"></A>        m_visited.insert(temp);
        while (!qu.empty()) {
            // cout &lt;&lt; &quot;qu_size&quot; &lt;&lt; qu.size() &lt;&lt; endl;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match12-0.html#1',2,'match12-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>            vector&lt;int&gt; temp = qu.front(); qu.pop();
            if (temp[0] == target_x &amp;&amp; temp[1] == target_y) {
                return temp[4];
            }
            for (int i = 0; i &lt; 4; i++) {
                int new_px = temp[0] + dx[i];
                int new_py = temp[1] + dy[i];
                visited.clear();
                // cout &lt;&lt; isValid(new_px, new_py, grid) &lt;&lt; endl;
                // cout &lt;&lt; canReach(new_px, new_py, temp[0], temp[1], temp[2], temp[3], grid) &lt;&lt; endl;
                if (isValid(new_px, new_py, grid) &amp;&amp; canReach(new_px, new_py, temp[0], temp[1], temp[2], temp[3], grid)) {</B></FONT>
                    vector&lt;int&gt; new_temp = temp;
                    new_temp[0]= temp[0] - dx[i];
                    new_temp[1] = temp[1] - dy[i];
                    new_temp[4] = 0;
                    if (isValid(new_temp[0], new_temp[1], grid)) {
                        // cout &lt;&lt; new_temp[0] &lt;&lt; &quot; &quot; &lt;&lt; new_temp[1] &lt;&lt; endl;
                        new_temp[2] = new_px;
                        new_temp[3] = new_py;
                        if (m_visited.count(new_temp) == 0) {
                            // cout &lt;&lt; new_temp[0] &lt;&lt; &quot; &quot; &lt;&lt; new_temp[1] &lt;&lt; endl;
                            m_visited.insert(new_temp);
                            new_temp[4] = temp[4] + 1;
                            qu.push(new_temp);
                        }
                    }
                }
            }
        }
        return -1;
    }
};
</PRE>
</BODY>
</HTML>
