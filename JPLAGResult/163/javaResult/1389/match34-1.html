<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>131_robinz62.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>131_robinz62.java</CENTER></H3><HR>
<PRE>
class Solution {
    public int minPushBox(char[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
<A NAME="2"></A>        
        // locate box start, player start, and target
        // clear the board of them
        <FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#2',2,'match34-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int br = -1;
        int bc = -1;
        int pr = -1;
        int pc = -1;
        int tr = -1;
        int tc = -1;
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; m; j++) {
                if (grid[i][j] == 'B') {
                    br = i;
                    b</B></FONT>c = j;
                    grid[i][j] = '.';
                }
                if (grid[i][j] == 'S') {
                    pr = i;
                    pc = j;
                    grid[i][j] = '.';
<A NAME="3"></A>                }
                if (grid[i][j] == 'T') {
                    tr = i;
                    <FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#3',2,'match34-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>tc = j;
                    grid[i][j] = '.';
                }
            }
        }
        
        Map&lt;Position, int[][]&gt; boxPosToCCState = new</B></FONT> HashMap&lt;&gt;();
        
        // compute layouts where box is anywhere
        for (int i = 0; i &lt; n; i++) {
            for (int j = 0; j &lt; m; j++) {
                char c = grid[i][j];
                if (c == '#') continue;
                if (c == '.') {
                    boxPosToCCState.put(new Position(i, j), computeBoardState(grid, i, j));
                }
            }
        }
        
        Position initBox = new Position(br, bc);
        int[][] initBoard = boxPosToCCState.get(initBox);
        GameState init = new GameState(initBox, initBoard[pr][pc]);
        
        Set&lt;GameState&gt; visited = new HashSet&lt;&gt;();
        Deque&lt;GameState&gt; q = new ArrayDeque&lt;&gt;();
        q.addLast(init);
        visited.add(init);
        int pushes = 0;
        while (!q.isEmpty()) {
            int size = q.size();
            for (int i = 0; i &lt; size; i++) {
                GameState curr = q.removeFirst();
                Position boxPos = curr.boxPos;
                if (boxPos.r == tr &amp;&amp; boxPos.c == tc) {
                    return pushes;
                }
                int[][] ccGrid = boxPosToCCState.get(boxPos);
                // if (boxPos.r == 2 &amp;&amp; boxPos.c == 1) printGrid(ccGrid);
                // try pushing right
                if (boxPos.c+1 &lt; m &amp;&amp; grid[boxPos.r][boxPos.c+1] == '.' &amp;&amp;
                    boxPos.c-1 &gt;= 0 &amp;&amp; curr.playerCCNumber == ccGrid[boxPos.r][boxPos.c-1]) {
                    Position nextBoxPos = new Position(boxPos.r, boxPos.c + 1);
                    int[][] nextCCGrid = boxPosToCCState.get(nextBoxPos);
                    GameState next = new GameState(nextBoxPos, nextCCGrid[boxPos.r][boxPos.c]);
                    if (!visited.contains(next)) {
                        q.addLast(next);
                        visited.add(next);
                    }
                }
                // left
                if (boxPos.c-1 &gt;= 0 &amp;&amp; grid[boxPos.r][boxPos.c-1] == '.' &amp;&amp;
                    boxPos.c+1 &lt; m &amp;&amp; curr.playerCCNumber == ccGrid[boxPos.r][boxPos.c+1]) {
                    Position nextBoxPos = new Position(boxPos.r, boxPos.c-1);
                    int[][] nextCCGrid = boxPosToCCState.get(nextBoxPos);
                    GameState next = new GameState(nextBoxPos, nextCCGrid[boxPos.r][boxPos.c]);
                    if (!visited.contains(next)) {
                        q.addLast(next);
                        visited.add(next);
                    }
                }
                // up
                if (boxPos.r-1 &gt;= 0 &amp;&amp; grid[boxPos.r-1][boxPos.c] == '.' &amp;&amp;
                    boxPos.r+1 &lt; n &amp;&amp; curr.playerCCNumber == ccGrid[boxPos.r+1][boxPos.c]) {
                    Position nextBoxPos = new Position(boxPos.r-1, boxPos.c);
                    int[][] nextCCGrid = boxPosToCCState.get(nextBoxPos);
                    GameState next = new GameState(nextBoxPos, nextCCGrid[boxPos.r][boxPos.c]);
                    if (!visited.contains(next)) {
                        q.addLast(next);
                        visited.add(next);
                    }
                }
                // down
                if (boxPos.r+1 &lt; n &amp;&amp; grid[boxPos.r+1][boxPos.c] == '.' &amp;&amp;
                    boxPos.r-1 &gt;= 0 &amp;&amp; curr.playerCCNumber == ccGrid[boxPos.r-1][boxPos.c]) {
                    Position nextBoxPos = new Position(boxPos.r+1, boxPos.c);
                    int[][] nextCCGrid = boxPosToCCState.get(nextBoxPos);
                    GameState next = new GameState(nextBoxPos, nextCCGrid[boxPos.r][boxPos.c]);
                    if (!visited.contains(next)) {
<A NAME="4"></A>                        q.addLast(next);
                        visited.add(next);
                    }
                <FONT color="#151b8d"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#4',2,'match34-top.html#4',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
            }
            
            pushes++;
        }
        return -1;
    }</B></FONT>
    
    // r, c is where to put the box
    int[][] computeBoardState(char[][] grid, int r, int c) {
        // if (r == 2 &amp;&amp; c == 1) printGrid(grid);
        grid[r][c] = 'X';
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        Deque&lt;int[]&gt; q = new ArrayDeque&lt;&gt;();
        int[][] ccGrid = new int[grid.length][grid[0].length];
        int ccNumber = 1;
        for (int i = 0; i &lt; grid.length; i++) {
            for (int j = 0; j &lt; grid[0].length; j++) {
                if (grid[i][j] == '.' &amp;&amp; !visited[i][j]) {
                    q.addLast(new int[]{i, j});
                    visited[i][j] = true;
                    ccGrid[i][j] = ++ccNumber;
                    while (!q.isEmpty()) {
                        int[] curr = q.removeFirst();
                        int x = curr[0];
                        int y = curr[1];
                        if (x-1 &gt;= 0 &amp;&amp; !visited[x-1][y] &amp;&amp; grid[x-1][y] == '.') {
                            q.addLast(new int[]{x-1, y});
                            visited[x-1][y] = true;
                            ccGrid[x-1][y] = ccNumber;
                        }
                        if (x+1 &lt; grid.length &amp;&amp; !visited[x+1][y] &amp;&amp; grid[x+1][y] == '.') {
                            q.addLast(new int[]{x+1, y});
                            visited[x+1][y] = true;
                            ccGrid[x+1][y] = ccNumber;
                        }
                        if (y-1 &gt;= 0 &amp;&amp; !visited[x][y-1] &amp;&amp; grid[x][y-1] == '.') {
                            q.addLast(new int[]{x, y-1});
                            visited[x][y-1] = true;
                            ccGrid[x][y-1] = ccNumber;
                        }
                        if (y+1 &lt; grid[0].length &amp;&amp; !visited[x][y+1] &amp;&amp; grid[x][y+1] == '.') {
                            q.addLast(new int[]{x, y+1});
                            visited[x][y+1] = true;
                            ccGrid[x][y+1] = ccNumber;
                            
                        }
                    }
                }
            }
        }
        grid[r][c] = '.';
        return ccGrid;
    }
    
    void printGrid(int[][] grid) {
        for (int i = 0; i &lt; grid.length; i++) {
            for (int j = 0; j &lt; grid[0].length; j++) {
                System.out.print(grid[i][j] + &quot; &quot;);
            }
            System.out.println();
        }
    }
    
    void printGrid(char[][] grid) {
        System.out.println(&quot;h&quot;);
        for (int i = 0; i &lt; grid.length; i++) {
            for (int j = 0; j &lt; grid[0].length; j++) {
                System.out.print(grid[i][j] + &quot; &quot;);
            }
            System.out.println();
        }
    }
    
    class Position {
<A NAME="0"></A>        int r;
        int c;
        public Position(int i, int j) {
            <FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#0',2,'match34-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>r = i;
            c = j;
        }
        @Override
        public boolean equals(Object o) {
            if (!(o instanceof Position)) return false;</B></FONT>
            Position p = (Position) o;
            return r == p.r &amp;&amp; c == p.c;
        }
        @Override
        public int hashCode() {
            return r * 2 + c * 3;
        }
    }
    
    class GameState {
        Position boxPos;
        int playerCCNumber;
        public GameState(Position p, int num) {
            boxPos = p;
            playerCCNumber = num;
        }
        @Override
        public boolean equals(Object o) {
<A NAME="1"></A>            if (!(o instanceof GameState)) return false;
            GameState gs = (GameState) o;
            return boxPos.equals(gs.boxPos) &amp;&amp; playerCCNumber == gs.playerCCNumber;
        <FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match34-0.html#1',2,'match34-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}
        @Override
        public int hashCode() {
            return boxPos.hashCode() * playerCCNumber;
        }
    }</B></FONT>
}
</PRE>

</BODY>
</HTML>
