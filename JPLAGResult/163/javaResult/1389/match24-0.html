<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>175_botao-4.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>175_botao-4.java</CENTER></H3><HR>
<PRE>
<A NAME="0"></A>class Solution {
    <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match24-1.html#0',3,'match24-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>int[][] dirs = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};

    private long key(int[] pos</B></FONT>){
        return pos[0] + pos[1] * 100 + pos[2] * 100 * 100 + pos[3] * 100 * 100 * 100;
    }

    private boolean valid(char[][] grid,int[] ele,HashMap&lt;Long,Integer&gt; visited){
        if(ele[0] &lt; 0 || ele[0] &gt;= grid.length || ele[1] &lt; 0 || ele[1] &gt;= grid[0].length) return false;
        if(grid[ele[0]][ele[1]] == '#') return false;
        if(ele[2] &lt; 0 || ele[2] &gt;= grid.length || ele[3] &lt; 0 || ele[3] &gt;= grid[0].length) return false;
        if(grid[ele[2]][ele[3]] == '#') return false;
        int prv = visited.getOrDefault(key(ele),0);
        if(prv != 0 &amp;&amp; prv &lt;= ele[4]) return false;
        if(ele[4] == 0 &amp;&amp; visited.containsKey(key(ele))) return false;
        return true;
<A NAME="1"></A>    }

    public int minPushBox(char[][] grid) {
        <FONT color="#f63526"><A HREF="javascript:ZweiFrames('match24-1.html#1',3,'match24-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>HashMap&lt;Long,Integer&gt; set = new HashMap&lt;&gt;();
        int pi = -1,pj = -1,bi = -1,bj = -1,ti = -1,tj = -1;
        for (int i = 0; i &lt; grid.length; i++) {
            for (int j = 0; j &lt; grid[0].length; j++) {
                if(grid[i][j] == 'S'){
                    pi = i;
                    pj = j;
                }else if(grid[i][j] == 'B'){
                    bi = i;
                    bj = j;
                }else if(grid[i][j] == 'T'){
                    ti = i;
                    tj = j;
                }
            }
        }</B></FONT>
        //System.out.println(&quot;ti = &quot; + ti + &quot; tj = &quot; + tj + &quot; bi = &quot; + bi + &quot; bj = &quot; + bj);
        Queue&lt;int[]&gt; q = new LinkedList&lt;&gt;();
        q.offer(new int[]{pi,pj,bi,bj,0});
        set.put(key(new int[]{pi,pj,bi,bj,0}),0);

        int step = Integer.MAX_VALUE;
        while (!q.isEmpty()){
            int len = q.size();
            //System.out.println(&quot;step = &quot; + step + &quot; len = &quot; + len);
            for (int i = 0; i &lt; len; i++) {
                int[] ele = q.poll();
                
                if(ele[2] == ti &amp;&amp; ele[3] == tj){
                    step = Math.min(step,ele[4]);
                    continue;
                };
                for(int[] dir : dirs){
                    int[] nele = new int[]{ele[0],ele[1],ele[2],ele[3],ele[4]};
                    nele[0] += dir[0];
                    nele[1] += dir[1];
                    if(nele[0] == nele[2] &amp;&amp; nele[1] == nele[3]){
                        nele[2] += dir[0];
                        nele[3] += dir[1];
                        nele[4] += 1;
                    }
                    if(valid(grid,nele,set)){
                        q.offer(nele);
                        set.put(key(nele),nele[4]);
                    }
                }
            }
        }
        return step == Integer.MAX_VALUE ? -1 : step;
    }
}
</PRE>

</BODY>
</HTML>
