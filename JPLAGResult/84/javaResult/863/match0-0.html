<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>314_abcdefat.java</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>314_abcdefat.java</CENTER></H3><HR>
<PRE>
class Solution {
    public int[] sumOfDistancesInTree(int N, int[][] edges) {
        // two round process: from bottom to up and from up to bottom
        // bfs from leaf
        Set&lt;Integer&gt;[] sets = build(N, edges);
        
        int[] nC = new int[N]; // the number of child nodes
        int[] sC = new int[N]; // the sum distance to child nodes
        
        List&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();
        
        for (int i = 0; i &lt; N; ++i) {
            
            if (sets[i].size() == 1) queue.add(i); // the leaf nodes
            
        }
        
        int[] pa = new int[N]; // store the parent
        for (int i = 0; i &lt; N; ++i) pa[i] = -1;
        
        List&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();
        
        while (!queue.isEmpty()) {
            
            // remove the leaf nodes
            int m = queue.size();
            // corner case: if two nodes connected
            if (m == 2) {
                
                int tmp1 = queue.get(0);
                int tmp2 = queue.get(1);
                
                if (sets[tmp1].contains(tmp2) &amp;&amp; sets[tmp2].contains(tmp1)) {
                    
                    //the last two nodes
                    int stmp1 = sC[tmp1] + sC[tmp2] + nC[tmp2] + 1;
                    int stmp2 = sC[tmp2] + sC[tmp1] + nC[tmp1] + 1;
                    int ntmp1 = nC[tmp1] + nC[tmp2] + 1;
                    int ntmp2 = nC[tmp2] + nC[tmp1] + 1;
                    
                    sC[tmp1] = stmp1;
                    sC[tmp2] = stmp2;
                    nC[tmp1] = ntmp1;
                    nC[tmp2] = ntmp2;
                    
                    break;
                }
                
            }
            
            // Set&lt;Integer&gt; next = new HashSet&lt;Integer&gt;();
            
            for (int i = 0; i &lt; m; ++i) {
                
                int leaf = queue.remove(0);
                // find the parent
                int parent = -1;
                for (int tmp: sets[leaf]) parent = tmp;
                if (parent == -1) break;
                nC[parent] += nC[leaf] + 1;
                sC[parent] += sC[leaf] + nC[leaf] + 1; // to each child node, the distance should increase by 1
                
                // remove the leaf
                sets[leaf].remove(parent);
                sets[parent].remove(leaf);
                
                // put leaf in stack
                pa[leaf] = parent;
                stack.add(0, leaf);
                
                if (sets[parent].size() == 1) queue.add(parent); 
    
            }
           
        }
        
        //round 2
        while (!stack.isEmpty()) {
            // find its parent
            int cur = stack.remove(0);
            int parent = pa[cur];
            // remove the nodes from current branch
            int dist = sC[parent] - sC[cur] - nC[cur] - 1;
            dist += N - nC[cur] - 1;
            sC[cur] += dist;
            
        }
        
        return sC;
        
    }
    
<A NAME="0"></A>    private Set&lt;Integer&gt;[] build(int N, int[][] edges) {
        
        // build the neighoring nodes
        <FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match0-1.html#0',3,'match0-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Set&lt;Integer&gt;[] res = (Set&lt;Integer&gt;[])new Set&lt;?&gt;[N];
        for (int i = 0; i &lt; N; ++i) res[i] = new HashSet&lt;Integer&gt;();
        
        for (int[] edge: edges) {
            
            res[edge[0]].add(edge[1]);
            res[edge[1]].add(edge[0]);
            
        }</B></FONT>
        return res;
        
    }
}
</PRE>

</BODY>
</HTML>
